
# <img width="24" src="./assets/linqraft.png" /> Linqraft 

[![NuGet Version](https://img.shields.io/nuget/v/Linqraft?style=flat-square&logo=NuGet&color=0080CC)](https://www.nuget.org/packages/Linqraft/) ![GitHub Actions Workflow Status](https://img.shields.io/github/actions/workflow/status/arika0093/Linqraft/test.yaml?branch=main&label=Test&style=flat-square) [![DeepWiki](https://img.shields.io/badge/DeepWiki-Linqraft-blue.svg?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAyCAYAAAAnWDnqAAAAAXNSR0IArs4c6QAAA05JREFUaEPtmUtyEzEQhtWTQyQLHNak2AB7ZnyXZMEjXMGeK/AIi+QuHrMnbChYY7MIh8g01fJoopFb0uhhEqqcbWTp06/uv1saEDv4O3n3dV60RfP947Mm9/SQc0ICFQgzfc4CYZoTPAswgSJCCUJUnAAoRHOAUOcATwbmVLWdGoH//PB8mnKqScAhsD0kYP3j/Yt5LPQe2KvcXmGvRHcDnpxfL2zOYJ1mFwrryWTz0advv1Ut4CJgf5uhDuDj5eUcAUoahrdY/56ebRWeraTjMt/00Sh3UDtjgHtQNHwcRGOC98BJEAEymycmYcWwOprTgcB6VZ5JK5TAJ+fXGLBm3FDAmn6oPPjR4rKCAoJCal2eAiQp2x0vxTPB3ALO2CRkwmDy5WohzBDwSEFKRwPbknEggCPB/imwrycgxX2NzoMCHhPkDwqYMr9tRcP5qNrMZHkVnOjRMWwLCcr8ohBVb1OMjxLwGCvjTikrsBOiA6fNyCrm8V1rP93iVPpwaE+gO0SsWmPiXB+jikdf6SizrT5qKasx5j8ABbHpFTx+vFXp9EnYQmLx02h1QTTrl6eDqxLnGjporxl3NL3agEvXdT0WmEost648sQOYAeJS9Q7bfUVoMGnjo4AZdUMQku50McDcMWcBPvr0SzbTAFDfvJqwLzgxwATnCgnp4wDl6Aa+Ax283gghmj+vj7feE2KBBRMW3FzOpLOADl0Isb5587h/U4gGvkt5v60Z1VLG8BhYjbzRwyQZemwAd6cCR5/XFWLYZRIMpX39AR0tjaGGiGzLVyhse5C9RKC6ai42ppWPKiBagOvaYk8lO7DajerabOZP46Lby5wKjw1HCRx7p9sVMOWGzb/vA1hwiWc6jm3MvQDTogQkiqIhJV0nBQBTU+3okKCFDy9WwferkHjtxib7t3xIUQtHxnIwtx4mpg26/HfwVNVDb4oI9RHmx5WGelRVlrtiw43zboCLaxv46AZeB3IlTkwouebTr1y2NjSpHz68WNFjHvupy3q8TFn3Hos2IAk4Ju5dCo8B3wP7VPr/FGaKiG+T+v+TQqIrOqMTL1VdWV1DdmcbO8KXBz6esmYWYKPwDL5b5FA1a0hwapHiom0r/cKaoqr+27/XcrS5UwSMbQAAAABJRU5ErkJggg==)](https://deepwiki.com/arika0093/Linqraft)

Write Select queries easily with on-demand DTO generation and null-propagation operators. No dependencies.

[Web Page](https://arika0093.github.io/Linqraft/) | [Online Playground](https://arika0093.github.io/Linqraft/playground/)

## Features
### Overview
Linqraft is a Roslyn Source Generator for easily writing `IQueryable` projections with null-propagation and automatic DTO generation.

* **Query-based** automatic DTO generation
  * You can freely define DTO structures in the query without predefining them.
  * Based on anonymous types, "what you see is what you get" declarations.
  * Supports nested DTOs, collections, and calculated fields.
* Null-propagation operator support (`?.`) in Expression Trees
  * No more need to write `o.Customer != null ? o.Customer.Name : null`.
* Zero-dependency
  * No additional runtime dependencies are required since it uses Source Generators and Interceptors.

With Linqraft, you can write queries like this:

```csharp
var orders = await dbContext.Orders
    // Order: input entity type
    // OrderDto: output DTO type (auto-generated)
    .SelectExpr<Order, OrderDto>(o => new
    {
        // can use inferred member names
        o.Id,
        // null-propagation supported
        // you can create flattened structures easily
        CustomerName = o.Customer?.Name,
        // also works for nested objects
        CustomerCountry = o.Customer?.Address?.Country?.Name,
        CustomerCity = o.Customer?.Address?.City?.Name,
        // you can use anonymous types inside. great for grouping
        CustomerInfo = new
        {
            Email = o.Customer?.EmailAddress,
            Phone = o.Customer?.PhoneNumber,
        },
        // calculated fields? no problem!
        LatestOrderDate = o.OrderItems.Max(oi => oi.OrderDate),
        TotalAmount = o.OrderItems.Sum(oi => oi.Quantity * oi.UnitPrice),
        // collections available
        Items = o.OrderItems.Select(oi => new
        {
            // of course, features work here too
            ProductName = oi.Product?.Name,
            oi.Quantity
        }),
    })
    .ToListAsync();
```

By specifying `OrderDto` as the generic parameter for `SelectExpr`, DTO types are generated **automatically** from the anonymous-type selector.
That means **you don't need to manually declare** `OrderDto` or `OrderItemDto`.  
Better yet, since these features are provided as a source generator, no additional dependencies are introduced.

for example, the generated code looks like this:

<details>
<summary>Generated code example</summary>

```csharp
// <auto-generated>
// This file is auto-generated by Linqraft 
// </auto-generated>
#nullable enable
#pragma warning disable IDE0060
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604
#pragma warning disable CS8618
using System;
using System.Linq;
using System.Collections.Generic;
namespace Linqraft
{
    file static partial class GeneratedExpression
    {
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "HWIj1D9ydZTCzRj7o0y/oYkBAABUdXRvcmlhbENhc2VUZXN0LmNz")]
        public static IQueryable<TResult> SelectExpr_CE7A5A7D_5A34E201<TIn, TResult>(
            this IQueryable<TIn> query, Func<TIn, object> selector)
        {
            var matchedQuery = query as object as IQueryable<global::Tutorial.Order>;
            var converted = matchedQuery.Select(o => new global::Tutorial.OrderDto
            {
                Id = o.Id,
                CustomerName = o.Customer != null ? (string?)o.Customer.Name : null,
                CustomerCountry = o.Customer != null && o.Customer.Address != null && o.Customer.Address.Country != null ? (string?)o.Customer.Address.Country.Name : null,
                CustomerCity = o.Customer != null && o.Customer.Address != null && o.Customer.Address.City != null ? (string?)o.Customer.Address.City.Name : null,
                CustomerInfo = new global::Tutorial.LinqraftGenerated_F1A64BF4.CustomerInfoDto
                {
                    Email = o.Customer != null ? (string?)o.Customer.EmailAddress : null,
                    Phone = o.Customer != null ? (string?)o.Customer.PhoneNumber : null
                },
                LatestOrderDate = o.OrderItems.Max(oi => oi.OrderDate),
                TotalAmount = o.OrderItems.Sum(oi => oi.Quantity * oi.UnitPrice),
                Items = o.OrderItems
                    .Select(oi => new global::Tutorial.LinqraftGenerated_DE33EA40.ItemsDto
                    {
                        ProductName = oi.Product != null ? (string?)oi.Product.Name : null,
                        Quantity = oi.Quantity
                    })
            });
            return converted as object as IQueryable<TResult>;
        }

    }
}
namespace Tutorial
{
    public partial class OrderDto
    {
        public required int Id { get; set; }
        public required string? CustomerName { get; set; }
        public required string? CustomerCountry { get; set; }
        public required string? CustomerCity { get; set; }
        public required global::Tutorial.LinqraftGenerated_F1A64BF4.CustomerInfoDto? CustomerInfo { get; set; }
        public required global::System.DateTime LatestOrderDate { get; set; }
        public required decimal TotalAmount { get; set; }
        public required global::System.Collections.Generic.IEnumerable<Tutorial.LinqraftGenerated_DE33EA40.ItemsDto> Items { get; set; }
    }
}
namespace Tutorial.LinqraftGenerated_DE33EA40
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Linqraft.LinqraftAutoGeneratedDtoAttribute]
    public partial class ItemsDto
    {
        public required string? ProductName { get; set; }
        public required int Quantity { get; set; }
    }
}
namespace Tutorial.LinqraftGenerated_F1A64BF4
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [Linqraft.LinqraftAutoGeneratedDtoAttribute]
    public partial class CustomerInfoDto
    {
        public required string? Email { get; set; }
        public required string? Phone { get; set; }
    }
}
```

</details>

### Drop-in Replacement Analyzers

[Analyzers](./docs/analyzers/README.md) are provided to replace existing Select code with Linqraft. The replacement is completed in an instant.

![](./assets/replace-codefix-sample.gif)

## Usage
### Prerequisites
This library requirements **C# 12.0 or later** because it uses the [interceptor](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12#interceptors) feature.  


<details>
<summary>.NET 7 or below setup</summary>

Set the `LangVersion` property to `12.0` or later and use [Polysharp](https://github.com/Sergio0694/PolySharp/) to enable C# latest features.

```xml
<Project>
  <PropertyGroup>
    <LangVersion>12.0</LangVersion>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Polysharp" Version="1.*" />
  </ItemGroup>
</Project>
```

</details>

Also, due to the constraints of `Microsoft.CodeAnalysis.CSharp`, One of the following environment is [required](https://andrewlock.net/supporting-multiple-sdk-versions-in-analyzers-and-source-generators/):

* .NET 8.0.400 or later **SDK**
* Visual Studio 2022 version 17.11 or later

> [!NOTE]
> This is only a constraint on the SDK side, so the runtime(target framework) can be older versions.

### Installation

Install `Linqraft` from NuGet.

```bash
dotnet add package Linqraft
```

## Examples
### Anonymous pattern

Use `SelectExpr` without generics to get an anonymous-type projection:

```csharp
var orders = await dbContext.Orders
    .SelectExpr(o => new
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToListAsync();
```

### Explicit DTO pattern
If you want to change the result to a DTO class, simply specify the generics as follows.

```csharp
var orders = await dbContext.Orders
    // Order: input entity type
    // OrderDto: output DTO type (auto-generated)
    .SelectExpr<Order, OrderDto>(o => new
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToListAsync();
```

Similarly, you can use only the auto-generation feature by specifying `IEnumerable` types.

```csharp
var orders = MySampleList
    .SelectExpr<Order, OrderDto>(o => new
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToList();
```

> [!TIP]
> If you want to use the auto-generated type information, you can navigate to the generated code (for example via F12 in your editor) by placing the cursor on the `OrderDto` class.
> and then you can copy it or use it as you like.


### Pre-existing DTO pattern
If you already have DTO classes and want to use them directly, call `SelectExpr` without generics and construct your DTO type in the selector:

```csharp
var orders = await dbContext.Orders
    .SelectExpr(o => new OrderDto
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToListAsync();

// your existing DTO class
public class OrderDto { /* ... */ }
```

## Customize Auto-Generated Code
### Pass Local-Variables
local variables cannot be used directly inside `SelectExpr` because it is "translated" into another method. To use local variables, use capture arguments.

```csharp
var val = 10;
var multiplier = 2;
var suffix = " units";
var converted = dbContext.Entities
    .SelectExpr<Entity, EntityDto>(
        x => new {
            x.Id,
            // cannot use local variable 'val' directly
            NewValue = x.Value + val,
            DoubledValue = x.Value * multiplier,
            Description = x.Name + suffix,
        },
        // you need to pass local variables as an object.
        capture: new { val, multiplier, suffix }
    );
```

<details>
<summary>Generated code example</summary>

```csharp
// code snippet
public static IQueryable<TResult> SelectExpr_223F344D_DD65E389<TIn, TResult>(
    this IQueryable<TIn> query, Func<TIn, TResult> selector, object captureParam)
{
    var matchedQuery = query as object as IQueryable<global::Entity>;
    dynamic captureObj = captureParam;
    int val = captureObj.val;
    int multiplier = captureObj.multiplier;
    string suffix = captureObj.suffix;
    var converted = matchedQuery.Select(x => new global::EntityDto
    {
        Id = x.Id,
        NewValue = x.Value + val,
        DoubledValue = x.Value * multiplier,
        Description = x.Name + suffix,
    });
    return converted as object as IQueryable<TResult>;
}
```

</details>

An analyzer is also provided to automatically detect and apply this transformation.
It is detected as an error, so just apply the code fix.

![](./assets/local-variable-capture-err.png)

### Removing nullability from arrays
Generally, DTO class types should be generated as specified. However, for array types, it is convenient for null tolerance to be automatically removed during generation.
This is because with array types, there is rarely a need to distinguish between `null` and `[]`.

Linqraft automatically removes nullability from array-type properties according to the following rules.
* Expression should NOT contain a ternary operator
* The type must be IEnumerable<T> or derived (List, Array, etc.)
* The expression uses null-conditional access (?.)
* The expression contains a Select or SelectMany call

For example, the following transformation is performed.

```csharp
query.SelectExpr<Entity, EntityDto>(e => new
{
    // in general, this property is generated as List<string>?
    // but Linqraft removes nullability for array types.
    // so the generated type is List<string>
    ChildNames = e.Child?.Select(c => c.Name).ToList(),

    // This also applies to auto-generated child classes.
    // so the generated type is IEnumerable<ChildDto>
    ChildDtos = e.Child?.Select(c => new { c.Name, c.Description }),

    // When explicitly comparing with a ternary operator, it is generated as a nullable type as usual.
    // therefore, in this case, it is generated as List<string>?
    ExplicitNullableNames = e.Child != null ? e.Child.Select(c => c.Name).ToList() : null,
});
```

<details>
<summary>Generated code example</summary>

```csharp
// code snippet
var converted = matchedQuery.Select(d => new global::EntityDto
{
    ChildNames = d.Child != null ? d.Child.Select(c => c.Name).ToList() : new List<int>(),
    ChildDtos = d.Child != null ? d.Child
        .Select(c => new global::LinqraftGenerated_HASH1234.ChildDto
        {
            Name = c.Name,
            Description = c.Description
        }) : Enumerable.Empty<global::LinqraftGenerated_HASH1234.ChildDto>(),
    ExplicitNullableNames = d.Child != null ? d.Child.Select(c => c.Name).ToList() : null,
});

// generated DTO class
public partial class EntityDto
{
    public required List<string> ChildNames { get; set; }
    public required IEnumerable<global::LinqraftGenerated_HASH1234.ChildDto> ChildDtos { get; set; }
    public required List<string>? ExplicitNullableNames { get; set; }
}
```

</details>

This change helps avoid unnecessary null checks like `dto.ChildNames ?? []`, keeping the code simple.

If you don't like this behavior, you can disable it by setting the `LinqraftArrayNullabilityRemoval` property to `false`.

### Partial Classes
You can extend the generated DTO classes as needed since they are output as `partial` classes.

```csharp
// extend generated DTO class if needed
public partial class OrderDto
{
    public string GetDisplayName() => $"{Id}: {CustomerName}";
}
```

### Property Accessibility Control
If you want to make specific properties of the auto-generated DTO class `internal`, you can do so by predefining the properties as partial classes.

```csharp
public partial class ParentDto
{
    // This property will not be generated, so you can control its accessibility
    internal string InternalData { get; set; }
}

var orders = await dbContext.Orders
    .SelectExpr<Parent, ParentDto>(o => new 
    {
        Id = o.Id,
        PublicComment = o.Comment,
        InternalData = o.InternalField,
    })
    .ToListAsync();

// Generated code will look like this:
public partial class ParentDto
{
    public required int Id { get; set; }
    public required string PublicComment { get; set; }
}
```

### Remove Hash from Generated Class Names
By default, nested DTO classes are generated with a namespace containing a hash suffix (e.g., `LinqraftGenerated_HASH1234.ItemsDto`) to avoid class name conflicts.
You can change this behavior to use class names with a hash-suffixed (e.g., `ItemsDto_HASH1234`).
This setting can be controlled via the `LinqraftNestedDtoUseHashNamespace` property.

<details>
<summary>Generated code example</summary>

**LinqraftNestedDtoUseHashNamespace = true (default)**

```csharp
namespace Tutorial
{
    public partial class OrderDto
    {
        public required System.Collections.Generic.List<global::Tutorial.LinqraftGenerated_DE33EA40.ItemsDto> Items { get; set; }
    }
}
namespace Tutorial.LinqraftGenerated_DE33EA40
{
    public partial class ItemsDto
    {
        public required string? ProductName { get; set; }
    }
}
```

**LinqraftNestedDtoUseHashNamespace = false**

```csharp
namespace Tutorial
{
    public partial class OrderDto
    {
        public required System.Collections.Generic.List<global::Tutorial.OrderItemDto_DE33EA40> Items { get; set; }
    }

    public partial class OrderItemDto_DE33EA40
    {
        public required string? ProductName { get; set; }
    }
}
```

</details>

### Auto generated comments
Linqraft attempts to retrieve comments attached to the original properties as much as possible and attach them as XML documentation comments to the properties of the DTO class.
In addition, reference information indicating what kind of query the DTO class was generated from is also attached.
This feature can be controlled using the `LinqraftCommentOutput` property.

<details>
<summary>Generated code example with comments</summary>

```csharp
// based entity class with comments
public class Entity
{
    /// <summary>
    /// XML summary comment
    /// </summary>
    [Key]
    public int Id { get; set; }

    [Comment("EFCore Comment")]
    public int Item1 { get; set; }

    [Display(Name = "Display Comment")]
    public int Item2 { get; set; }

    public List<ChildEntity> Childs { get; set; }
}
public class ChildEntity
{
    // single-line comment are also supported
    public int ChildId { get; set; }
}

// and use SelectExpr
query.SelectExpr<Entity, EntityDto>(e => new
{
    Id = e.Id,
    Item1Value = e.Item1,
    Item2Value = e.Item2,
    ChildIds = e.Childs.Select(c => c.ChildId).ToList(),
});
```

generates the following DTO class:

```csharp
/// <summary>
/// based entity class with comments
/// </summary>
/// <remarks>
/// From: <c>Entity</c>
/// </remarks>
public partial class EntityDto
{
    /// <summary>
    /// XML summary comment
    /// </summary>
    /// <remarks>
    /// From: <c>Entity.Id</c>
    /// Attributes: <c>[Key]</c>
    /// </remarks>
    public required int Id { get; set; }

    /// <summary>
    /// EFCore Comment
    /// </summary>
    /// <remarks>
    /// From: <c>Entity.Item1</c>
    /// </remarks>
    public required int Item1Value { get; set; }

    /// <summary>
    /// Display Comment
    /// </summary>
    /// <remarks>
    /// From: <c>Entity.Item2</c>
    /// </remarks>
    public required int Item2Value { get; set; }

    /// <summary>
    /// single-line comment are also supported
    /// </summary>
    /// <remarks>
    /// From: <c>Entity.Childs.Select(...).ToList()</c>
    /// </remarks>
    public required System.Collections.Generic.List<int> ChildIds { get; set; }
}
```
</details>


### Global Properties
Linqraft supports several MSBuild properties to customize the generated code:

```xml
<Project>
  <!-- The values listed are the default values. -->
  <PropertyGroup>
    <!-- set namespace if based-class is in global namespace. empty means use global namespace -->
    <LinqraftGlobalNamespace></LinqraftGlobalNamespace>
    <!-- generate records instead of classes -->
    <LinqraftRecordGenerate>false</LinqraftRecordGenerate>
    <!-- set accessor pattern. Default, GetAndSet, GetAndInit, GetAndInternalSet -->
    <!-- default is GetAndSet in class, GetAndInit in record -->
    <LinqraftPropertyAccessor>Default</LinqraftPropertyAccessor>
    <!-- has required keyword on properties -->
    <LinqraftHasRequired>true</LinqraftHasRequired>
    <!-- generate xml documentation comments on properties -->
    <!-- All(summary+reference), SummaryOnly(summary), None(no comments) -->
    <LinqraftCommentOutput>All</LinqraftCommentOutput>
    <!-- remove nullability from array-type properties -->
    <LinqraftArrayNullabilityRemoval>true</LinqraftArrayNullabilityRemoval>
    <!-- generate nested DTOs in hash-named namespace (e.g., LinqraftGenerated_HASH.ItemsDto) -->
    <!-- instead of hash-suffixed class names (e.g., ItemsDto_HASH) -->
    <LinqraftNestedDtoUseHashNamespace>true</LinqraftNestedDtoUseHashNamespace>
  </PropertyGroup>
</Project>
```

## Performance

<details>
<summary>Benchmark Results</summary>

```
BenchmarkDotNet v0.15.8, Windows 11 (10.0.26200.7171/25H2/2025Update/HudsonValley2)
Intel Core i7-14700F 2.10GHz, 1 CPU, 28 logical and 20 physical cores
.NET SDK 10.0.100
  [Host]     : .NET 10.0.0 (10.0.0, 10.0.25.52411), X64 RyuJIT x86-64-v3
  DefaultJob : .NET 10.0.0 (10.0.0, 10.0.25.52411), X64 RyuJIT x86-64-v3


| Method                        | Mean     | Error   | StdDev  | Ratio | Rank | Gen0    | Gen1   | Allocated | Alloc Ratio |
|------------------------------ |---------:|--------:|--------:|------:|-----:|--------:|-------:|----------:|------------:|
| 'Linqraft Auto-Generated DTO' | 880.9 us | 5.00 us | 4.68 us |  0.91 |    1 | 13.6719 | 1.9531 | 245.69 KB |        1.00 |
| 'Linqraft Manual DTO'         | 886.9 us | 7.25 us | 6.78 us |  0.92 |    1 | 13.6719 | 1.9531 | 245.93 KB |        1.00 |
| 'Traditional Manual DTO'      | 898.2 us | 7.53 us | 7.04 us |  0.93 |    1 | 13.6719 | 1.9531 | 245.65 KB |        1.00 |
| 'Linqraft Anonymous'          | 955.2 us | 6.37 us | 5.65 us |  0.99 |    2 | 13.6719 | 1.9531 |  245.2 KB |        0.99 |
| 'Traditional Anonymous'       | 966.1 us | 6.50 us | 6.08 us |  1.00 |    2 | 13.6719 | 1.9531 | 246.73 KB |        1.00 |
```

</details>

Compared to the manual approach, the performance is nearly identical.
for more details, see [Linqraft.Benchmark](./examples/Linqraft.Benchmark) for details.

## Comparison with Other Libraries
Mapping is a common task, and many libraries exist.
Here, instead of comparing performance and pros and cons in detail, we will explain the main differences.

<details>
<summary>Compared Libraries</summary>

### [AutoMapper](https://automapper.io/)
* You need to predefine the destination DTO.
* Mapping rules are set up in advance using `MapperConfiguration`.
    * Highly configurable, but not type-safe.
* For Select queries, use the `ProjectTo<TDestination>` method.
* **Paid license required** for commercial use from version 15 onward.

### [Mapster](https://github.com/MapsterMapper/Mapster)
* You need to predefine the destination DTO.
    * You can generate DTOs using `Mapster.Tool`, but it must be run as a separate process.
* For Select queries, use the `ProjectToType<TDestination>` method.
* Customizing the structure requires manual configuration one by one using `NewConfig.Map(...)`.

### [Mapperly](https://mapperly.riok.app/)
* You need to predefine the destination DTO.
* The conversion process is auto-generated by a source generator and is easy to read.
* Customizing the conversion is possible, but you need to define your own methods, which adds some extra steps.
  * Although it can also be specified with attributes, you need to [explicitly specify the properties](https://mapperly.riok.app/docs/configuration/flattening/) before and after conversion.

### [Facet](https://github.com/Tim-Maes/Facet)
* Automatically generates DTOs from existing types.
    * You can prepare multiple DTOs as needed.
    * However, you must explicitly control what gets generated using `Include`/`Exclude` attributes.
* Nested objects can be retrieved without `.Include()` queries.
    * However, according to the documentation, you need to specify them explicitly with `NestedFacets`.
* With EFCore extensions, update queries and more are also auto-generated.
* Overall, it's feature-rich but the configuration can be somewhat complex.

### [Linqraft](https://arika0093.github.io/Linqraft/)
* Automatically generates DTOs based on query definitions.
    * In contrast, Traditional generators generate queries from class definitions.
    * This allows you to flexibly generate DTO structures that do not depend on the original class structure.
        * With traditional solutions, the original class structure is the base, so complex customizations or computed fields require extra effort.
* Zero-dependency because it uses source generators and interceptors.
    * However, it requires a relatively recent environment (C# 12.0 or later).
* On the other hand, since it's query-based, it's not suitable for generating shared DTOs referenced from multiple projects.
    * You can mitigate this by generating objects separately from schemas like OpenAPI.
* Reverse conversion from DTO to the original entity is not supported.
    * This is an intentional trade-off for the flexibility mentioned aboveâ€”reverse conversion of computed fields would be ambiguous.

</details>

In summary (admittedly subjective!), it looks like this:

| Library    | DTO Definition | Generation | Customization | Reverse | License    |
| ---------- | -------------- | ---------- | ------------- | ------- | ---------- |
| AutoMapper | Manual         | From class | Config-based  | Yes     | Paid (15+) |
| Mapster    | Manual         | From class | Config-based  | Yes     | MIT        |
| Mapperly   | Manual         | From class | Code/Attr     | Yes     | Apache 2.0 |
| Facet      | Semi-auto      | From class | Attributes    | Yes     | MIT        |
| Linqraft   | Auto           | From query | Inline        | No      | Apache 2.0 |

## Frequently Asked Questions
### Can I use Linqraft with EF Core only?
No. It can be used with any LINQ provider that supports `IEnumerable` and/or `IQueryable`.

### Can the generated DTOs be used elsewhere?
Yes. You can use the generated DTOs anywhere, such as API result models, Swagger documentation, function return types, arguments, variables, and more.
For example, see [here](./examples/Linqraft.ApiSample) for an example of using it in an API.

### Can I access the generated code?
Yes. `Go to Definition (F12)` on the generated DTO class name will take you to the generated code.
Alternatively, you can also output the generated code to files by adding the following settings to your project.

```xml
<Project>
  <PropertyGroup>
    <!-- flag to emit generated files -->
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <!-- output path for generated files -->
    <CompilerGeneratedFilesOutputPath>Generated</CompilerGeneratedFilesOutputPath>
  </PropertyGroup>
</Project>
```

## License
This project is licensed under the Apache License 2.0.
