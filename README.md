
# EFCore.ExprGenerator

[![NuGet Version](https://img.shields.io/nuget/v/EFCore.ExprGenerator?style=flat-square&logo=NuGet&color=0080CC)](https://www.nuget.org/packages/EFCore.ExprGenerator/) ![GitHub Actions Workflow Status](https://img.shields.io/github/actions/workflow/status/arika0093/EFCore.ExprGenerator/test.yaml?branch=main&label=Test&style=flat-square) ![GitHub last commit (branch)](https://img.shields.io/github/last-commit/arika0093/EFCore.ExprGenerator?style=flat-square)

Simplifies Select query expressions for EntityFrameworkCore (EF Core) by providing automatic DTO generation and support for null-propagating expressions.

[English](./README.md) | [Japanese](./README.ja.md)

## Problem

When querying a table that has many related tables, using `Include` / `ThenInclude` quickly makes code hard to read and maintain.

- The Include-based style becomes verbose and hard to follow.
- Forgetting an `Include` can lead to runtime `NullReferenceException`s that are hard to detect at compile time.
- Fetching entire object graphs is often wasteful and hurts performance.

Example (unreadable, inefficient, and error-prone):

```csharp
var orders = await dbContext.Orders
    .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
            .ThenInclude(a => a.Country)
    .Include(o => o.Customer)
        .ThenInclude(c => c.Address)
            .ThenInclude(a => a.City)
    .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.Product)
    .ToListAsync();
```

A better approach is to project into DTOs and select only the fields you need:

```csharp
var orders = await dbContext.Orders
    .Select(o => new OrderDto
    {
        Id = o.Id,
        CustomerName = o.Customer.Name,
        CustomerCountry = o.Customer.Address.Country.Name,
        CustomerCity = o.Customer.Address.City.Name,
        Items = o.OrderItems.Select(oi => new OrderItemDto
        {
            ProductName = oi.Product.Name,
            Quantity = oi.Quantity
        }).ToList()
    })
    .ToListAsync();
```

This yields better performance because only the required data is fetched. But this style has drawbacks:

- If you want to pass the result to other methods or return it from APIs, you usually must define DTO classes manually.
- When child objects can be null, the expression APIs don't support the `?.` operator directly, forcing verbose null checks using ternary operators.

Because null-propagation isn't supported inside expression trees, code often becomes verbose:

```csharp
var orders = await dbContext.Orders
    .Select(o => new OrderDto
    {
        Id = o.Id,
        CustomerName = o.Customer != null ? o.Customer.Name : null,
        CustomerCountry = o.Customer != null && o.Customer.Address != null && o.Customer.Address.Country != null
            ? o.Customer.Address.Country.Name
            : null,
        CustomerCity = o.Customer != null && o.Customer.Address != null && o.Customer.Address.City != null
            ? o.Customer.Address.City.Name
            : null,
        Items = o.OrderItems != null
            ? o.OrderItems.Select(oi => new OrderItemDto
            {
                ProductName = oi.Product != null ? oi.Product.Name : null,
                Quantity = oi.Quantity
            }).ToList()
            : new List<OrderItemDto>()
    })
    .ToListAsync();
```

## Features

EFCore.ExprGenerator is a Roslyn Source Generator that addresses the problems above. Using this library you can write concise selectors with null-propagation and optionally generate DTO classes automatically.

Example with auto-generated DTOs and null-propagation support:

```csharp
using EFCore.ExprGenerator;

var orders = await dbContext.Orders
    // Order: input entity type
    // OrderDto: output DTO type (auto-generated)
    .SelectExpr<Order, OrderDto>(o => new
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        CustomerCountry = o.Customer?.Address?.Country?.Name,
        CustomerCity = o.Customer?.Address?.City?.Name,
        Items = o.OrderItems?.Select(oi => new
        {
            ProductName = oi.Product?.Name,
            Quantity = oi.Quantity
        })
    })
    .ToListAsync();
```

By specifying `OrderDto` as the generic parameter for `SelectExpr`, DTO types are generated automatically from the anonymous-type selector. That means you don't need to manually declare `OrderDto` or `OrderItemDto`.

A generated example (simplified):

<details>
<summary>Generated code example</summary>

```csharp
// <auto-generated />
#nullable enable
// ... generated SelectExpr method that performs the projection with null checks ...

public class OrderItemDto_XXXXXX
{
    public required string? ProductName { get; set; }
    public required int Quantity { get; set; }
}

public class OrderDto
{
    public required int Id { get; set; }
    public required string? CustomerName { get; set; }
    public required string? CustomerCountry { get; set; }
    public required string? CustomerCity { get; set; }
    public required System.Collections.Generic.IEnumerable<OrderItemDto_XXXXXX>? Items { get; set; }
}
```

</details>

## Usage

### Prerequisites

This library uses C# interceptors internally, so it requires .NET 8.0 or later.

### Installation

Install the package from NuGet:

```
dotnet add package EFCore.ExprGenerator --prerelease
```

Enable the interceptor namespace in your project file:

```xml
<Project>
  <PropertyGroup>
    <!-- add EFCore.ExprGenerator to the InterceptorsPreviewNamespaces -->
    <InterceptorsPreviewNamespaces>$(InterceptorsPreviewNamespaces);EFCore.ExprGenerator</InterceptorsPreviewNamespaces>
  </PropertyGroup>
</Project>
```

### Examples

Use `SelectExpr` without generics to get an anonymous-type projection:

```csharp
var orders = await dbContext.Orders
    .SelectExpr(o => new
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToListAsync();
```

To use the auto-generated DTOs, provide the target DTO type as a generic argument:

```csharp
var orders = await dbContext.Orders
    .SelectExpr<Order, OrderDto>(o => new
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToListAsync();
```

If you already have DTO classes and want to use them directly, call `SelectExpr` without generics and construct your DTO type in the selector:

```csharp
var orders = await dbContext.Orders
    .SelectExpr(o => new OrderDto
    {
        Id = o.Id,
        CustomerName = o.Customer?.Name,
        // ...
    })
    .ToListAsync();

// your existing DTO class
public class OrderDto { /* ... */ }
```

> Tip: When DTOs are auto-generated, you can navigate to the generated code (for example via F12 in your editor) to inspect and reuse the generated types.

## Notes

The translation of anonymous-type selectors into Select-compatible expressions is done by source generation and some heuristics. Very complex expressions or certain C# constructs may not be supported. If you encounter unsupported cases, please open an issue with a minimal repro.

Although the repository name contains "EFCore", the library has no runtime dependency on EF Core and can be used with any IQueryable provider that supports projection.

## License

This project is licensed under the Apache License 2.0.
