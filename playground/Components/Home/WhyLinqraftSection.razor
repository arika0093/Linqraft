@inject IJSRuntime JS

<section id="why-section" class="bg-gradient-to-b from-gray-950 to-gray-900 border-y border-gray-800">
    <div class="max-w-5xl mx-auto px-6 py-16">
        <h2 class="text-2xl font-bold text-white mb-4 text-center">Why Linqraft?</h2>
        <p class="text-gray-400 text-center mb-8 max-w-3xl mx-auto">
            Consider a case where you need to fetch data from a database with many related tables.
        </p>
        
        <!-- Horizontal Navigation -->
        <nav class="flex justify-center gap-8 mb-12 border-b border-gray-800 pb-4">
            <a href="#include-problem" class="text-gray-400 hover:text-white transition-colors text-sm">Include Problem</a>
            <a href="#manual-dto" class="text-gray-400 hover:text-white transition-colors text-sm">Manual DTO</a>
            <a href="#linqraft-solution" class="text-gray-400 hover:text-white transition-colors text-sm">Linqraft Solution</a>
        </nav>

        <!-- Include Problem Section -->
        <div id="include-problem" class="mb-16">
            <h3 class="text-xl font-semibold text-white mb-4">The Include / ThenInclude Problem</h3>
            <p class="text-gray-300 mb-4">
                Writing it naively would involve heavy use of <InlineCode>Include</InlineCode> / <InlineCode>ThenInclude</InlineCode>, 
                resulting in code that is hard to read and maintain.
            </p>
            <ul class="space-y-2 text-gray-300 mb-6">
                <li class="flex items-start gap-2">
                    <span class="text-gray-500">•</span>
                    <span>The Include-based style becomes verbose and hard to follow.</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-gray-500">•</span>
                    <span>Forgetting an <InlineCode>Include</InlineCode> can lead to runtime <InlineCode>NullReferenceException</InlineCode>s that are hard to detect at compile time.</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-gray-500">•</span>
                    <span>Fetching entire object graphs is often wasteful and hurts performance.</span>
                </li>
            </ul>
            <CodeBlock Title="Include Pattern" Code="@includeCode" />
        </div>

        <!-- Manual DTO Section -->
        <div id="manual-dto" class="mb-16">
            <h3 class="text-xl font-semibold text-white mb-4">Manual DTO Projection</h3>
            <p class="text-gray-300 mb-4">
                A better approach is to project into DTOs and select only the fields you need. 
                This yields better performance because only the required data is fetched. But this style has drawbacks:
            </p>
            <ul class="space-y-2 text-gray-300 mb-6">
                <li class="flex items-start gap-2">
                    <span class="text-gray-500">•</span>
                    <span>If you want to pass the result to other methods or return it from APIs, you usually must define DTO classes manually.</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-gray-500">•</span>
                    <span>The expression APIs don't support the <InlineCode>?.</InlineCode> operator directly, forcing verbose null checks using ternary operators.</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-gray-500">•</span>
                    <span>The deeper the child elements become, the more complex null checks are required.</span>
                </li>
            </ul>
            <CodeBlock Title="Manual DTO Pattern" Code="@manualDtoCode" />
        </div>

        <!-- Linqraft Solution Section -->
        <div id="linqraft-solution">
            <h3 class="text-xl font-semibold text-white mb-4">The Linqraft Solution</h3>
            <p class="text-gray-300 mb-4">
                Linqraft solves these problems by providing <InlineCode>SelectExpr</InlineCode>, 
                which supports null-propagation operators and automatic DTO generation.
            </p>
            <ul class="space-y-2 text-gray-300 mb-6">
                <li class="flex items-start gap-2">
                    <span class="text-green-500">✓</span>
                    <span>Use <InlineCode>?.</InlineCode> naturally - Linqraft translates it for you</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-green-500">✓</span>
                    <span>No manual DTO definitions - auto-generated from anonymous types</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-green-500">✓</span>
                    <span>No runtime overhead - compile time generation via source generators</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-green-500">✓</span>
                    <span>Zero dependencies - only a source generator, no runtime library needed</span>
                </li>
            </ul>
            <CodeBlock Title="Linqraft Pattern" Code="@linqraftCode" Highlight />
        </div>
    </div>
</section>

@code {
    // Code from README - Include Pattern
    private const string includeCode = @"// unreadable, inefficient, and error-prone
var orders = await dbContext.Orders
    .Include(o => o.Customer).ThenInclude(c => c.Address).ThenInclude(a => a.Country)
    .Include(o => o.Customer).ThenInclude(c => c.Address).ThenInclude(a => a.City)
    .Include(o => o.OrderItems).ThenInclude(oi => oi.Product)
    .ToListAsync();

// if you forget an Include, you may get runtime NullReferenceExceptions
var invalidAccess = orders[0].Customer.Profile.EmailAddress;
// -> crash!";

    // Code from README - Manual DTO with null checks (full version)
    private const string manualDtoCode = @"// too ugly code with lots of null checks
var orders = await dbContext.Orders
    .Select(o => new OrderDto
    {
        Id = o.Id,
        // in expression trees, ?. is not supported
        CustomerName = o.Customer != null ? o.Customer.Name : null,
        // nested null checks get worse
        CustomerCountry = o.Customer != null && o.Customer.Address != null && o.Customer.Address.Country != null
            ? o.Customer.Address.Country.Name
            : null,
        CustomerCity = o.Customer != null && o.Customer.Address != null && o.Customer.Address.City != null
            ? o.Customer.Address.City.Name
            : null,
        Items = o.OrderItems.Select(oi => new OrderItemDto
        {
            // more null checks
            ProductName = oi.Product != null ? oi.Product.Name : null,
            Quantity = oi.Quantity
        })
    })
    .ToListAsync();

// you must define DTO classes manually
public class OrderDto
{
    public int Id { get; set; }
    public string? CustomerName { get; set; }
    public string? CustomerCountry { get; set; }
    public string? CustomerCity { get; set; }
    public List<OrderItemDto> Items { get; set; } = [];
}
// When child DTOs are deep, the problem worsens
public class OrderItemDto
{
    public string? ProductName { get; set; }
    public int Quantity { get; set; }
}";

    // Code from README - Linqraft Solution
    private const string linqraftCode = @"// usable null-propagation operators
var orders = await dbContext.Orders
    .SelectExpr<Order, OrderDto>(o => new
    {
        o.Id,
        CustomerName = o.Customer?.Name,
        CustomerCountry = o.Customer?.Address?.Country?.Name,
        CustomerCity = o.Customer?.Address?.City?.Name,
        Items = o.OrderItems.Select(oi => new
        {
            ProductName = oi.Product?.Name,
            oi.Quantity
        })
    })
    .ToListAsync();

// OrderDto and OrderItemDto classes are auto-generated";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("Prism.highlightAll");
        }
    }
}
