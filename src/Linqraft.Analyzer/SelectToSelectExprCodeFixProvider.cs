using System.Collections.Immutable;
using System.Composition;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Linqraft.Analyzer;

/// <summary>
/// Code fix provider that converts Select to SelectExpr
/// </summary>
[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(SelectToSelectExprCodeFixProvider)), Shared]
public class SelectToSelectExprCodeFixProvider : CodeFixProvider
{
    public sealed override ImmutableArray<string> FixableDiagnosticIds =>
        ImmutableArray.Create(
            DiagnosticDescriptors.SelectToSelectExpr.Id,
            DiagnosticDescriptors.EnhanceSelectExpr.Id);

    public sealed override FixAllProvider GetFixAllProvider() =>
        WellKnownFixAllProviders.BatchFixer;

    public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)
    {
        var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);
        if (root == null)
            return;

        var diagnostic = context.Diagnostics.First();
        var diagnosticSpan = diagnostic.Location.SourceSpan;

        // Find the invocation expression
        var token = root.FindToken(diagnosticSpan.Start);
        var invocation = token.Parent?.AncestorsAndSelf().OfType<InvocationExpressionSyntax>().First();
        if (invocation == null)
            return;

        var semanticModel = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);
        if (semanticModel == null)
            return;

        // Detect the pattern type
        var patternInfo = DetectPattern(invocation, semanticModel);

        // Register code fixes based on the detected pattern
        RegisterCodeFixesForPattern(context, diagnostic, invocation, patternInfo);
    }

    private void RegisterCodeFixesForPattern(
        CodeFixContext context,
        Diagnostic diagnostic,
        InvocationExpressionSyntax invocation,
        PatternInfo patternInfo)
    {
        // Pattern 1→3: Anonymous Select → Anonymous SelectExpr (always available for Select)
        if (patternInfo.IsSelect)
        {
            context.RegisterCodeFix(
                CodeAction.Create(
                    title: "Convert to SelectExpr (keep current projection)",
                    createChangedDocument: c => ConvertToAnonymousSelectExprAsync(context.Document, invocation, c),
                    equivalenceKey: "ConvertToAnonymousSelectExpr"),
                diagnostic);
        }

        // Pattern 1→4: Anonymous Select → Auto-generated SelectExpr (only for anonymous objects)
        if (patternInfo.IsSelect && patternInfo.UsesAnonymousType)
        {
            context.RegisterCodeFix(
                CodeAction.Create(
                    title: "Convert to SelectExpr<TDto> (auto-generate DTO)",
                    createChangedDocument: c => ConvertToAutoGeneratedSelectExprAsync(context.Document, invocation, c),
                    equivalenceKey: "ConvertToAutoGeneratedSelectExpr"),
                diagnostic);
        }

        // Pattern 2→4: Existing DTO Select → Auto-generated SelectExpr
        if (patternInfo.IsSelect && patternInfo.UsesPredefinedDto)
        {
            context.RegisterCodeFix(
                CodeAction.Create(
                    title: "Convert to SelectExpr<TDto> (auto-generate DTO)",
                    createChangedDocument: c => ConvertPredefinedToAutoGeneratedSelectExprAsync(context.Document, invocation, c),
                    equivalenceKey: "ConvertPredefinedToAutoGeneratedSelectExpr"),
                diagnostic);
        }

        // Pattern 3→4: Anonymous SelectExpr → Auto-generated SelectExpr
        if (patternInfo.IsSelectExpr && patternInfo.UsesAnonymousType)
        {
            context.RegisterCodeFix(
                CodeAction.Create(
                    title: "Convert to SelectExpr<TDto> (auto-generate DTO)",
                    createChangedDocument: c => ConvertAnonymousToAutoGeneratedSelectExprAsync(context.Document, invocation, c),
                    equivalenceKey: "ConvertAnonymousToAutoGeneratedSelectExpr"),
                diagnostic);
        }
    }

    private PatternInfo DetectPattern(InvocationExpressionSyntax invocation, SemanticModel semanticModel)
    {
        var patternInfo = new PatternInfo();

        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return patternInfo;

        var methodName = memberAccess.Name.Identifier.Text;
        patternInfo.IsSelect = methodName == "Select";
        patternInfo.IsSelectExpr = methodName == "SelectExpr";

        // Check if lambda uses anonymous type or predefined DTO
        if (invocation.ArgumentList.Arguments.Count > 0)
        {
            var argument = invocation.ArgumentList.Arguments[0];
            if (argument.Expression is SimpleLambdaExpressionSyntax simpleLambda)
            {
                AnalyzeLambdaBody(simpleLambda.Body, semanticModel, patternInfo);
            }
            else if (argument.Expression is ParenthesizedLambdaExpressionSyntax parenthesizedLambda)
            {
                AnalyzeLambdaBody(parenthesizedLambda.Body, semanticModel, patternInfo);
            }
        }

        return patternInfo;
    }

    private void AnalyzeLambdaBody(SyntaxNode body, SemanticModel semanticModel, PatternInfo patternInfo)
    {
        if (body is AnonymousObjectCreationExpressionSyntax)
        {
            patternInfo.UsesAnonymousType = true;
        }
        else if (body is ObjectCreationExpressionSyntax objectCreation)
        {
            var typeInfo = semanticModel.GetTypeInfo(objectCreation);
            if (typeInfo.Type != null && !typeInfo.Type.IsAnonymousType)
            {
                patternInfo.UsesPredefinedDto = true;
                patternInfo.DtoTypeName = typeInfo.Type.Name;
            }
        }
    }

    private class PatternInfo
    {
        public bool IsSelect { get; set; }
        public bool IsSelectExpr { get; set; }
        public bool UsesAnonymousType { get; set; }
        public bool UsesPredefinedDto { get; set; }
        public string? DtoTypeName { get; set; }
    }

    // Pattern 1→3: Anonymous Select → Anonymous SelectExpr
    private static async Task<Document> ConvertToAnonymousSelectExprAsync(
        Document document,
        InvocationExpressionSyntax invocation,
        CancellationToken cancellationToken)
    {
        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
        if (root == null)
            return document;

        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return document;

        // Create new member access with "SelectExpr" instead of "Select"
        var newMemberAccess = memberAccess.WithName(
            SyntaxFactory.IdentifierName("SelectExpr")
                .WithTriviaFrom(memberAccess.Name));

        // Create the new invocation
        var newInvocation = invocation.WithExpression(newMemberAccess);

        // Replace the old invocation with the new one
        var newRoot = root.ReplaceNode(invocation, newInvocation);

        return document.WithSyntaxRoot(newRoot);
    }

    // Pattern 1→4: Anonymous Select → Auto-generated SelectExpr
    private static async Task<Document> ConvertToAutoGeneratedSelectExprAsync(
        Document document,
        InvocationExpressionSyntax invocation,
        CancellationToken cancellationToken)
    {
        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);
        if (root == null || semanticModel == null)
            return document;

        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return document;

        // Get the source type from the query
        var symbolInfo = semanticModel.GetSymbolInfo(invocation, cancellationToken);
        if (symbolInfo.Symbol is not IMethodSymbol methodSymbol)
            return document;

        var sourceType = methodSymbol.TypeArguments.FirstOrDefault();
        if (sourceType == null)
            return document;

        // Generate a DTO name based on the source type
        var dtoName = $"{sourceType.Name}Dto";

        // Create SelectExpr<TSource, TDto> call
        var genericName = SyntaxFactory.GenericName(
            SyntaxFactory.Identifier("SelectExpr"),
            SyntaxFactory.TypeArgumentList(
                SyntaxFactory.SeparatedList(new[]
                {
                    SyntaxFactory.ParseTypeName(sourceType.ToDisplayString()),
                    SyntaxFactory.ParseTypeName(dtoName)
                })));

        var newMemberAccess = memberAccess.WithName(genericName.WithTriviaFrom(memberAccess.Name));
        var newInvocation = invocation.WithExpression(newMemberAccess);

        // Replace the old invocation with the new one
        var newRoot = root.ReplaceNode(invocation, newInvocation);

        return document.WithSyntaxRoot(newRoot);
    }

    // Pattern 2→4: Existing DTO Select → Auto-generated SelectExpr  
    private static async Task<Document> ConvertPredefinedToAutoGeneratedSelectExprAsync(
        Document document,
        InvocationExpressionSyntax invocation,
        CancellationToken cancellationToken)
    {
        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
        var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);
        if (root == null || semanticModel == null)
            return document;

        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return document;

        // Get the source type from the query
        var symbolInfo = semanticModel.GetSymbolInfo(invocation, cancellationToken);
        if (symbolInfo.Symbol is not IMethodSymbol methodSymbol)
            return document;

        var sourceType = methodSymbol.TypeArguments.FirstOrDefault();
        if (sourceType == null)
            return document;

        // Get the DTO type from the lambda body
        string? dtoName = null;
        if (invocation.ArgumentList.Arguments.Count > 0)
        {
            var argument = invocation.ArgumentList.Arguments[0];
            if (argument.Expression is SimpleLambdaExpressionSyntax simpleLambda)
            {
                if (simpleLambda.Body is ObjectCreationExpressionSyntax objectCreation)
                {
                    var typeInfo = semanticModel.GetTypeInfo(objectCreation, cancellationToken);
                    dtoName = typeInfo.Type?.Name;
                }
            }
        }

        if (dtoName == null)
            return document;

        // Convert object creation to anonymous object creation
        var newInvocation = ConvertObjectCreationToAnonymous(invocation, semanticModel, cancellationToken);
        if (newInvocation == null)
            return document;

        // Create SelectExpr<TSource, TDto> call
        var genericName = SyntaxFactory.GenericName(
            SyntaxFactory.Identifier("SelectExpr"),
            SyntaxFactory.TypeArgumentList(
                SyntaxFactory.SeparatedList(new[]
                {
                    SyntaxFactory.ParseTypeName(sourceType.ToDisplayString()),
                    SyntaxFactory.ParseTypeName(dtoName)
                })));

        var newMemberAccess = memberAccess.WithName(genericName.WithTriviaFrom(memberAccess.Name));
        newInvocation = newInvocation.WithExpression(newMemberAccess);

        // Replace the old invocation with the new one
        var newRoot = root.ReplaceNode(invocation, newInvocation);

        return document.WithSyntaxRoot(newRoot);
    }

    // Pattern 3→4: Anonymous SelectExpr → Auto-generated SelectExpr
    private static async Task<Document> ConvertAnonymousToAutoGeneratedSelectExprAsync(
        Document document,
        InvocationExpressionSyntax invocation,
        CancellationToken cancellationToken)
    {
        // This is similar to Pattern 1→4 but starts from SelectExpr
        return await ConvertToAutoGeneratedSelectExprAsync(document, invocation, cancellationToken);
    }

    private static InvocationExpressionSyntax? ConvertObjectCreationToAnonymous(
        InvocationExpressionSyntax invocation,
        SemanticModel semanticModel,
        CancellationToken cancellationToken)
    {
        if (invocation.ArgumentList.Arguments.Count == 0)
            return null;

        var argument = invocation.ArgumentList.Arguments[0];
        
        if (argument.Expression is SimpleLambdaExpressionSyntax simpleLambda)
        {
            if (simpleLambda.Body is ObjectCreationExpressionSyntax objectCreation)
            {
                var anonymousObject = ConvertToAnonymousObject(objectCreation);
                if (anonymousObject != null)
                {
                    var newLambda = simpleLambda.WithBody(anonymousObject);
                    var newArgument = argument.WithExpression(newLambda);
                    var newArgumentList = invocation.ArgumentList.WithArguments(
                        SyntaxFactory.SingletonSeparatedList(newArgument));
                    return invocation.WithArgumentList(newArgumentList);
                }
            }
        }

        return null;
    }

    private static AnonymousObjectCreationExpressionSyntax? ConvertToAnonymousObject(
        ObjectCreationExpressionSyntax objectCreation)
    {
        if (objectCreation.Initializer == null)
            return null;

        var initializers = objectCreation.Initializer.Expressions
            .OfType<AssignmentExpressionSyntax>()
            .Select(assignment =>
                SyntaxFactory.AnonymousObjectMemberDeclarator(
                    SyntaxFactory.NameEquals(
                        SyntaxFactory.IdentifierName(
                            ((IdentifierNameSyntax)assignment.Left).Identifier)),
                    assignment.Right))
            .ToArray();

        return SyntaxFactory.AnonymousObjectCreationExpression(
            SyntaxFactory.SeparatedList(initializers));
    }

    private static async Task<Document> ConvertToSelectExprAsync(
        Document document,
        InvocationExpressionSyntax invocation,
        CancellationToken cancellationToken)
    {
        var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
        if (root == null)
            return document;

        // Get the member access expression (e.g., "query.Select")
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return document;

        // Create new member access with "SelectExpr" instead of "Select"
        var newMemberAccess = memberAccess.WithName(
            SyntaxFactory.IdentifierName("SelectExpr")
                .WithTriviaFrom(memberAccess.Name));

        // Create the new invocation
        var newInvocation = invocation.WithExpression(newMemberAccess);

        // Replace the old invocation with the new one
        var newRoot = root.ReplaceNode(invocation, newInvocation);

        return document.WithSyntaxRoot(newRoot);
    }
}
