using System.Linq;
using Linqraft.Core.AnalyzerHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Linqraft.Analyzer;

/// <summary>
/// Analyzer that detects explicit usage of auto-generated DTO types marked with LinqraftAutoGeneratedDtoAttribute.
/// This helps prevent users from explicitly depending on auto-generated DTOs which may change on regeneration.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class AutoGeneratedDtoUsageAnalyzer : BaseLinqraftAnalyzer
{
    public const string AnalyzerId = "LQRW002";

    private static readonly DiagnosticDescriptor RuleInstance = new(
        AnalyzerId,
        "Explicit use of auto-generated DTO type",
        "Type '{0}' is an auto-generated DTO. Auto-generated DTOs may change on regeneration. Consider using 'var' or explicit DTO types instead.",
        "Usage",
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Explicitly using auto-generated DTO types may lead to compilation errors when DTOs are regenerated. Consider using 'var' for variable declarations or defining your own DTO types.",
        helpLinkUri: $"https://github.com/arika0093/Linqraft/blob/main/docs/analyzer/{AnalyzerId}.md"
    );

    protected override string DiagnosticId => AnalyzerId;
    protected override LocalizableString Title => RuleInstance.Title;
    protected override LocalizableString MessageFormat => RuleInstance.MessageFormat;
    protected override LocalizableString Description => RuleInstance.Description;
    protected override string Category => "Usage";
    protected override DiagnosticSeverity Severity => DiagnosticSeverity.Warning;
    protected override DiagnosticDescriptor Rule => RuleInstance;

    protected override void RegisterActions(AnalysisContext context)
    {
        // Check object creation expressions (new GeneratedDto(...))
        context.RegisterSyntaxNodeAction(
            AnalyzeObjectCreation,
            SyntaxKind.ObjectCreationExpression
        );

        // Check parameter declarations (void Foo(GeneratedDto dto))
        context.RegisterSyntaxNodeAction(AnalyzeParameter, SyntaxKind.Parameter);

        // Check variable declarations (GeneratedDto dto = ...)
        context.RegisterSyntaxNodeAction(
            AnalyzeVariableDeclaration,
            SyntaxKind.VariableDeclaration
        );

        // Check property declarations (public GeneratedDto MyDto { get; set; })
        context.RegisterSyntaxNodeAction(
            AnalyzePropertyDeclaration,
            SyntaxKind.PropertyDeclaration
        );

        // Check field declarations (private GeneratedDto _myDto;)
        context.RegisterSyntaxNodeAction(AnalyzeFieldDeclaration, SyntaxKind.FieldDeclaration);
    }

    private void AnalyzeObjectCreation(SyntaxNodeAnalysisContext context)
    {
        var objectCreation = (ObjectCreationExpressionSyntax)context.Node;

        // Get the type being created
        var typeInfo = context.SemanticModel.GetTypeInfo(objectCreation, context.CancellationToken);
        var type = typeInfo.Type;

        if (type != null && HasAutoGeneratedDtoAttribute(type))
        {
            ReportDiagnostic(context, objectCreation.Type.GetLocation(), type.Name);
        }
    }

    private void AnalyzeParameter(SyntaxNodeAnalysisContext context)
    {
        var parameter = (ParameterSyntax)context.Node;

        // Skip if no explicit type (e.g., in lambda expressions with inferred types)
        if (parameter.Type == null)
        {
            return;
        }

        var typeInfo = context.SemanticModel.GetTypeInfo(parameter.Type, context.CancellationToken);
        var type = typeInfo.Type;

        if (type != null && HasAutoGeneratedDtoAttribute(type))
        {
            ReportDiagnostic(context, parameter.Type.GetLocation(), type.Name);
        }
    }

    private void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context)
    {
        var variableDeclaration = (VariableDeclarationSyntax)context.Node;

        // Skip if using 'var' (implicit type)
        if (variableDeclaration.Type.IsVar)
        {
            return;
        }

        // Skip if this is part of a field declaration (handled by AnalyzeFieldDeclaration)
        if (variableDeclaration.Parent is FieldDeclarationSyntax)
        {
            return;
        }

        var typeInfo = context.SemanticModel.GetTypeInfo(
            variableDeclaration.Type,
            context.CancellationToken
        );
        var type = typeInfo.Type;

        if (type != null && HasAutoGeneratedDtoAttribute(type))
        {
            ReportDiagnostic(context, variableDeclaration.Type.GetLocation(), type.Name);
        }
    }

    private void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context)
    {
        var propertyDeclaration = (PropertyDeclarationSyntax)context.Node;

        var typeInfo = context.SemanticModel.GetTypeInfo(
            propertyDeclaration.Type,
            context.CancellationToken
        );
        var type = typeInfo.Type;

        if (type != null && HasAutoGeneratedDtoAttribute(type))
        {
            ReportDiagnostic(context, propertyDeclaration.Type.GetLocation(), type.Name);
        }
    }

    private void AnalyzeFieldDeclaration(SyntaxNodeAnalysisContext context)
    {
        var fieldDeclaration = (FieldDeclarationSyntax)context.Node;

        var typeInfo = context.SemanticModel.GetTypeInfo(
            fieldDeclaration.Declaration.Type,
            context.CancellationToken
        );
        var type = typeInfo.Type;

        if (type != null && HasAutoGeneratedDtoAttribute(type))
        {
            ReportDiagnostic(context, fieldDeclaration.Declaration.Type.GetLocation(), type.Name);
        }
    }

    /// <summary>
    /// Checks if a type has the LinqraftAutoGeneratedDtoAttribute applied.
    /// </summary>
    private static bool HasAutoGeneratedDtoAttribute(ITypeSymbol type)
    {
        // Check direct attributes on the type
        return type.GetAttributes()
            .Any(attr =>
            {
                var attrClass = attr.AttributeClass;
                if (attrClass == null)
                {
                    return false;
                }

                // Optimized check: compare Name and ContainingNamespace instead of ToDisplayString()
                if (attrClass.Name != "LinqraftAutoGeneratedDtoAttribute")
                {
                    return false;
                }

                var containingNamespace = attrClass.ContainingNamespace;
                return containingNamespace != null
                    && !containingNamespace.IsGlobalNamespace
                    && containingNamespace.Name == "Linqraft"
                    && containingNamespace.ContainingNamespace?.IsGlobalNamespace == true;
            });
    }

    private void ReportDiagnostic(
        SyntaxNodeAnalysisContext context,
        Location location,
        string typeName
    )
    {
        var diagnostic = Diagnostic.Create(RuleInstance, location, typeName);
        context.ReportDiagnostic(diagnostic);
    }
}
