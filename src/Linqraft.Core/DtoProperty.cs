using System;
using System.Collections.Generic;
using System.Linq;
using Linqraft.Core.RoslynHelpers;
using Linqraft.Core.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Linqraft.Core;

/// <summary>
/// Represents a property in a DTO structure with metadata for code generation
/// </summary>
public record DtoProperty(
    string Name,
    bool IsNullable,
    string OriginalExpression,
    ExpressionSyntax OriginalSyntax,
    ITypeSymbol TypeSymbol,
    DtoStructure? NestedStructure,
    string? Accessibility = null,
    bool IsNestedFromNamedType = false,
    DocumentationCommentHelper.DocumentationInfo? Documentation = null,
    /// <summary>
    /// The explicit DTO type specified in SelectExpr&lt;TIn, TResult&gt; generic arguments.
    /// When this is set, the generated expression should use this type instead of auto-generating one.
    /// </summary>
    ITypeSymbol? ExplicitNestedDtoType = null,
    /// <summary>
    /// The explicit DTO type name as a string, used when the type symbol might be an error type
    /// (because the DTO is generated by another SelectExpr). This stores the fully qualified name.
    /// </summary>
    string? ExplicitNestedDtoTypeName = null
)
{
    /// <summary>
    /// Gets the fully qualified type name of the property
    /// </summary>
    public string TypeName
    {
        get
        {
            // Check if the type symbol is an error type or invalid
            if (
                TypeSymbol is IErrorTypeSymbol
                || TypeSymbol.SpecialType == SpecialType.System_Object
            )
            {
                return "object";
            }

            var typeName = TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            // Fallback to a safe type if the type name is empty or invalid
            if (string.IsNullOrWhiteSpace(typeName))
            {
                return "object";
            }
            return typeName;
        }
    }

    /// <summary>
    /// Analyzes an expression and creates a DtoProperty from it
    /// </summary>
    /// <param name="propertyName">The name of the property</param>
    /// <param name="expression">The expression syntax to analyze</param>
    /// <param name="semanticModel">The semantic model for type resolution</param>
    /// <param name="targetProperty">Optional target property symbol (for predefined DTOs)</param>
    /// <param name="accessibility">Optional accessibility modifier (e.g., "public", "internal")</param>
    /// <returns>A DtoProperty instance or null if analysis fails</returns>
    public static DtoProperty? AnalyzeExpression(
        string propertyName,
        ExpressionSyntax expression,
        SemanticModel semanticModel,
        IPropertySymbol? targetProperty = null,
        string? accessibility = null,
        LinqraftConfiguration? configuration = null
    )
    {
        var typeInfo = semanticModel.GetTypeInfo(expression);
        var propertyType = typeInfo.Type ?? typeInfo.ConvertedType;
        if (propertyType is null)
            return null;

        // Determine nullability: prefer the expression's type over the targetProperty's type
        // This is important for lambda expressions where the anonymous type may lose nullability info
        NullableAnnotation nullableAnnotation;

        // For direct member access (e.g., s.Name), get nullability from the source member
        if (expression is MemberAccessExpressionSyntax memberAccess)
        {
            var memberSymbol = semanticModel.GetSymbolInfo(memberAccess).Symbol;
            if (memberSymbol is IPropertySymbol sourceProp)
            {
                (propertyType, nullableAnnotation) = GetTypeInfoFromSymbol(sourceProp);
            }
            else if (memberSymbol is IFieldSymbol sourceField)
            {
                (propertyType, nullableAnnotation) = GetTypeInfoFromSymbol(sourceField);
            }
            else if (targetProperty is not null)
            {
                (propertyType, nullableAnnotation) = GetTypeInfoFromSymbol(targetProperty);
            }
            else
            {
                nullableAnnotation = propertyType.NullableAnnotation;
            }
        }
        // For invocation expressions (e.g., .Select(...).ToList()), prefer expression's type
        // The anonymous type may incorrectly mark collections as nullable based on their contents
        else if (expression is InvocationExpressionSyntax invocation)
        {
            // For collection creation methods, ensure the collection itself is not nullable
            // even if it contains nullable elements
            if (ShouldForceNonNullableCollection(invocation))
            {
                // Force the collection to be non-nullable
                propertyType = propertyType.WithNullableAnnotation(NullableAnnotation.NotAnnotated);
                nullableAnnotation = NullableAnnotation.NotAnnotated;
            }
            else
            {
                // Use the expression's own type information (from typeInfo at line 66)
                nullableAnnotation = propertyType.NullableAnnotation;
            }
        }
        // For other expressions (operators, etc.), use targetProperty if available
        else if (targetProperty is not null)
        {
            (propertyType, nullableAnnotation) = GetTypeInfoFromSymbol(targetProperty);
        }
        else
        {
            nullableAnnotation = propertyType.NullableAnnotation;
        }

        var isNullable = nullableAnnotation == NullableAnnotation.Annotated;

        // Check if nullable operator ?. is used
        var hasNullableAccess = HasNullableAccess(expression);

        // Syntax-based nullable detection (fallback for Visual Studio issues)
        // If Roslyn returns None (unreliable in VS), use syntax-based heuristics
        var shouldGenerateNullCheck = ShouldGenerateNullCheckFromSyntax(expression);
        if (nullableAnnotation == NullableAnnotation.None && shouldGenerateNullCheck)
        {
            // Override: treat as nullable based on syntax
            isNullable = true;
        }

        // Detect nested SelectExpr first (e.g., s.Childs.SelectExpr<Item, ItemDto>(...) or nested SelectExpr calls)
        // When SelectExpr is used inside another SelectExpr, it should be treated like Select for structure analysis
        DtoStructure? nestedStructure = null;
        bool isNestedFromNamedType = false;
        ITypeSymbol? explicitNestedDtoType = null;
        string? explicitNestedDtoTypeName = null;
        var selectExprInvocation = FindSelectExprInvocation(expression);
        if (
            selectExprInvocation is not null
            && selectExprInvocation.ArgumentList.Arguments.Count > 0
        )
        {
            var lambdaArg = selectExprInvocation.ArgumentList.Arguments[0].Expression;
            if (lambdaArg is LambdaExpressionSyntax nestedLambda)
            {
                // Get collection element type from the SelectExpr's source
                ITypeSymbol? collectionType = null;

                if (
                    selectExprInvocation.Expression
                    is MemberAccessExpressionSyntax selectExprMemberAccess
                )
                {
                    // For generic SelectExpr<TIn, TResult>, get the base expression before the .SelectExpr call
                    var baseExpr = selectExprMemberAccess.Expression;
                    collectionType = semanticModel.GetTypeInfo(baseExpr).Type;

                    // Extract the explicit DTO type (TResult) from SelectExpr<TIn, TResult>
                    if (
                        selectExprMemberAccess.Name is GenericNameSyntax genericName
                        && genericName.TypeArgumentList.Arguments.Count >= 2
                    )
                    {
                        var tResultSyntax = genericName.TypeArgumentList.Arguments[1];
                        explicitNestedDtoType = semanticModel.GetTypeInfo(tResultSyntax).Type;

                        // Use the type symbol to get the fully qualified name (including parent classes)
                        // If the type symbol is not available or is an error type, use syntax-based name extraction
                        if (
                            explicitNestedDtoType is not null
                            && explicitNestedDtoType is not IErrorTypeSymbol
                        )
                        {
                            explicitNestedDtoTypeName = explicitNestedDtoType.ToDisplayString(
                                SymbolDisplayFormat.FullyQualifiedFormat
                            );
                        }
                        else
                        {
                            // Fallback: build the name from syntax
                            // This happens when the DTO is generated by another SelectExpr and doesn't exist yet

                            var callerNamespace =
                                selectExprInvocation
                                    .Ancestors()
                                    .OfType<BaseNamespaceDeclarationSyntax>()
                                    .FirstOrDefault()
                                    ?.Name.ToString()
                                ?? "";

                            // Get the type name from syntax - it might already include parent class qualifiers
                            // e.g., "Issue_NestedSelectExprTest.NestedItemDtoEnumerable" or just "NestedItem207Dto"
                            var typeName = tResultSyntax.ToString();

                            // If the type name contains a dot, it's already qualified (e.g., "ClassName.DtoName")
                            // In that case, respect the qualification and don't modify it
                            // Otherwise, assume the DTO will be generated at the namespace level (NOT nested)
                            // unless the user has provided a partial class declaration indicating it should be nested

                            if (!string.IsNullOrEmpty(callerNamespace))
                            {
                                explicitNestedDtoTypeName = $"global::{callerNamespace}.{typeName}";
                            }
                            else
                            {
                                explicitNestedDtoTypeName = $"global::{typeName}";
                            }
                        }
                    }
                }

                if (
                    collectionType is INamedTypeSymbol namedCollectionType
                    && namedCollectionType.TypeArguments.Length > 0
                )
                {
                    var elementType = namedCollectionType.TypeArguments[0];

                    // Support both anonymous types and named types in the lambda body
                    if (
                        nestedLambda.Body is AnonymousObjectCreationExpressionSyntax nestedAnonymous
                    )
                    {
                        // For nested structures in SelectExpr, use null as hintName to ensure deduplication
                        // This prevents duplicate DTOs when the same structure is used in multiple properties
                        nestedStructure = DtoStructure.AnalyzeAnonymousType(
                            nestedAnonymous,
                            semanticModel,
                            elementType,
                            hintName: null,
                            configuration
                        );
                    }
                    else if (nestedLambda.Body is ObjectCreationExpressionSyntax nestedNamed)
                    {
                        nestedStructure = DtoStructure.AnalyzeNamedType(
                            nestedNamed,
                            semanticModel,
                            elementType,
                            hintName: null,
                            configuration
                        );
                        isNestedFromNamedType = true;
                    }
                }
            }
        }

        // Detect nested Select (e.g., s.Childs.Select(...) or s.Childs.Select(...).ToList())
        // Only if we didn't find a SelectExpr
        if (nestedStructure is null)
        {
            // First, try to find Select invocation (handles both direct Select and chained methods like ToList)
            var selectInvocation = FindSelectInvocation(expression);
            if (selectInvocation is not null && selectInvocation.ArgumentList.Arguments.Count > 0)
            {
                var lambdaArg = selectInvocation.ArgumentList.Arguments[0].Expression;
                if (lambdaArg is LambdaExpressionSyntax nestedLambda)
                {
                    // Get collection element type from the Select's source
                    ITypeSymbol? collectionType = null;

                    if (
                        selectInvocation.Expression
                        is MemberAccessExpressionSyntax selectMemberAccess
                    )
                    {
                        // Check if the base expression is a MemberBindingExpressionSyntax (part of conditional access)
                        // e.g., d.InnerData?.Childs.Select(...) - here .Childs is a MemberBindingExpressionSyntax
                        if (selectMemberAccess.Expression is MemberBindingExpressionSyntax)
                        {
                            // For conditional access chains (e.g., d.InnerData?.Childs.Select),
                            // we need to find the conditional access expression and get the type from there
                            var conditionalAccess = expression
                                .DescendantNodesAndSelf()
                                .OfType<ConditionalAccessExpressionSyntax>()
                                .FirstOrDefault();
                            if (conditionalAccess is not null)
                            {
                                // Get the type of the WhenNotNull part up to the collection
                                // For d.InnerData?.Childs.Select, we need to get the type of d.InnerData.Childs
                                // The semantic model can resolve the type of the conditional access expression result
                                // which includes the null-conditional path
                                var memberBinding = (MemberBindingExpressionSyntax)
                                    selectMemberAccess.Expression;
                                var memberName = memberBinding.Name.Identifier.Text;

                                // Get the type of the expression before the ?. operator
                                var baseType = semanticModel
                                    .GetTypeInfo(conditionalAccess.Expression)
                                    .Type;
                                if (baseType is not null)
                                {
                                    // Get the non-nullable underlying type if it's a nullable type
                                    // e.g., ChildData? -> ChildData
                                    var nonNullableBaseType =
                                        RoslynTypeHelper.GetNonNullableType(baseType) ?? baseType;

                                    // Find the member with the specified name on the base type
                                    var memberSymbol =
                                        nonNullableBaseType
                                            .GetMembers(memberName)
                                            .OfType<IPropertySymbol>()
                                            .FirstOrDefault()
                                        ?? (ISymbol?)
                                            nonNullableBaseType
                                                .GetMembers(memberName)
                                                .OfType<IFieldSymbol>()
                                                .FirstOrDefault();
                                    if (memberSymbol is IPropertySymbol propSymbol)
                                    {
                                        collectionType = propSymbol.Type;
                                    }
                                    else if (memberSymbol is IFieldSymbol fieldSymbol)
                                    {
                                        collectionType = fieldSymbol.Type;
                                    }
                                }
                            }
                        }
                        else
                        {
                            // Normal case: direct member access
                            collectionType = semanticModel
                                .GetTypeInfo(selectMemberAccess.Expression)
                                .Type;
                        }
                    }
                    else if (selectInvocation.Expression is MemberBindingExpressionSyntax)
                    {
                        // For conditional access (?.Select), we need to find the base expression
                        // Look for ConditionalAccessExpressionSyntax in ancestors
                        var conditionalAccess = expression
                            .DescendantNodesAndSelf()
                            .OfType<ConditionalAccessExpressionSyntax>()
                            .FirstOrDefault();
                        if (conditionalAccess is not null)
                        {
                            collectionType = semanticModel
                                .GetTypeInfo(conditionalAccess.Expression)
                                .Type;
                        }
                    }

                    if (
                        collectionType is INamedTypeSymbol namedCollectionType
                        && namedCollectionType.TypeArguments.Length > 0
                    )
                    {
                        var elementType = namedCollectionType.TypeArguments[0];

                        // Support both anonymous types and named types
                        if (
                            nestedLambda.Body
                            is AnonymousObjectCreationExpressionSyntax nestedAnonymous
                        )
                        {
                            // For nested structures in Select, use null as hintName to ensure deduplication
                            nestedStructure = DtoStructure.AnalyzeAnonymousType(
                                nestedAnonymous,
                                semanticModel,
                                elementType,
                                hintName: null,
                                configuration
                            );
                        }
                        else if (nestedLambda.Body is ObjectCreationExpressionSyntax nestedNamed)
                        {
                            nestedStructure = DtoStructure.AnalyzeNamedType(
                                nestedNamed,
                                semanticModel,
                                elementType,
                                hintName: null,
                                configuration
                            );
                            isNestedFromNamedType = true;
                        }
                    }
                }
            }
        } // Close the "if (nestedStructure is null)" block for Select detection

        // Detect nested SelectMany (e.g., s.Childs.SelectMany(c => c.GrandChilds))
        if (nestedStructure is null)
        {
            var selectManyInvocation = FindSelectManyInvocation(expression);
            if (
                selectManyInvocation is not null
                && selectManyInvocation.ArgumentList.Arguments.Count > 0
            )
            {
                var lambdaArg = selectManyInvocation.ArgumentList.Arguments[0].Expression;
                if (lambdaArg is LambdaExpressionSyntax nestedLambda)
                {
                    // Get collection element type from the SelectMany's source
                    ITypeSymbol? collectionType = null;

                    if (
                        selectManyInvocation.Expression
                        is MemberAccessExpressionSyntax selectManyMemberAccess
                    )
                    {
                        collectionType = semanticModel
                            .GetTypeInfo(selectManyMemberAccess.Expression)
                            .Type;
                    }
                    else if (selectManyInvocation.Expression is MemberBindingExpressionSyntax)
                    {
                        // For conditional access (?.SelectMany), we need to find the base expression
                        var conditionalAccess = expression
                            .DescendantNodesAndSelf()
                            .OfType<ConditionalAccessExpressionSyntax>()
                            .FirstOrDefault();
                        if (conditionalAccess is not null)
                        {
                            collectionType = semanticModel
                                .GetTypeInfo(conditionalAccess.Expression)
                                .Type;
                        }
                    }

                    if (
                        collectionType is INamedTypeSymbol namedCollectionType
                        && namedCollectionType.TypeArguments.Length > 0
                    )
                    {
                        var elementType = namedCollectionType.TypeArguments[0];

                        // For SelectMany, the lambda body should be a member access or invocation
                        // that returns a collection. We need to analyze what the lambda returns.
                        // The lambda body could be:
                        // 1. Simple member access: c => c.GrandChildren
                        // 2. Projection with Select: c => c.GrandChildren.Select(gc => new { ... })
                        // 3. Anonymous type with Select inside: c => new { Grands = c.GrandChildren.Select(...) }

                        // Check if the lambda body contains a Select
                        var innerSelectInvocation = nestedLambda.Body
                            is ExpressionSyntax lambdaBodyExpr
                            ? FindSelectInvocation(lambdaBodyExpr)
                            : null;
                        if (
                            innerSelectInvocation is not null
                            && innerSelectInvocation.ArgumentList.Arguments.Count > 0
                        )
                        {
                            var innerLambdaArg = innerSelectInvocation
                                .ArgumentList
                                .Arguments[0]
                                .Expression;
                            if (innerLambdaArg is LambdaExpressionSyntax innerLambda)
                            {
                                // Get the inner collection type
                                var innerCollectionType = nestedLambda.Body
                                    is ExpressionSyntax lambdaBodyForType
                                    ? semanticModel.GetTypeInfo(lambdaBodyForType).Type
                                    : null;
                                if (
                                    innerCollectionType is INamedTypeSymbol innerNamedType
                                    && innerNamedType.TypeArguments.Length > 0
                                )
                                {
                                    var innerElementType = innerNamedType.TypeArguments[0];

                                    if (
                                        innerLambda.Body
                                        is AnonymousObjectCreationExpressionSyntax innerAnonymous
                                    )
                                    {
                                        // For nested structures in SelectMany, use null as hintName to ensure deduplication
                                        nestedStructure = DtoStructure.AnalyzeAnonymousType(
                                            innerAnonymous,
                                            semanticModel,
                                            innerElementType,
                                            hintName: null,
                                            configuration
                                        );
                                    }
                                    else if (
                                        innerLambda.Body
                                        is ObjectCreationExpressionSyntax innerNamed
                                    )
                                    {
                                        nestedStructure = DtoStructure.AnalyzeNamedType(
                                            innerNamed,
                                            semanticModel,
                                            innerElementType,
                                            hintName: null,
                                            configuration
                                        );
                                        isNestedFromNamedType = true;
                                    }
                                }
                            }
                        }
                        else if (
                            nestedLambda.Body
                            is AnonymousObjectCreationExpressionSyntax anonymousBody
                        )
                        {
                            // Handle: c => new { Grands = c.GrandChildren.Select(...) }
                            // This is a SelectMany with an anonymous body (rare case).
                            // Use propertyName as hint because this is a direct anonymous type creation,
                            // not a Select projection, so we want to disambiguate different usages.
                            nestedStructure = DtoStructure.AnalyzeAnonymousType(
                                anonymousBody,
                                semanticModel,
                                elementType,
                                hintName: propertyName,
                                configuration
                            );
                        }
                        // Note: For simple member access like c => c.GrandChildren,
                        // we don't create a nested structure because the result is just
                        // a flattened collection of the existing type.
                    }
                }
            }
        }

        // Detect direct anonymous type creation (e.g., Channel = new { Id = ..., Name = ... })
        // This handles nested anonymous types that are not inside a Select call
        if (
            nestedStructure is null
            && expression is AnonymousObjectCreationExpressionSyntax directAnonymous
        )
        {
            // Get the source type from the anonymous type properties
            // We need to find the base type from which properties are being accessed
            ITypeSymbol? sourceTypeForNested = null;

            // Try to infer the source type from the first property that has a member access
            foreach (var initializer in directAnonymous.Initializers)
            {
                var initExpr = initializer.Expression;
                if (initExpr is MemberAccessExpressionSyntax initMemberAccess)
                {
                    // Get the type of the expression being accessed (e.g., q.Channel)
                    var baseTypeInfo = semanticModel.GetTypeInfo(initMemberAccess.Expression);
                    if (baseTypeInfo.Type is not null)
                    {
                        sourceTypeForNested = baseTypeInfo.Type;
                        break;
                    }
                }
            }

            // If we couldn't infer the source type, use the property type itself
            sourceTypeForNested ??= propertyType;

            // For direct nested anonymous types, use propertyName as hint to disambiguate
            // different usages of the same source type
            nestedStructure = DtoStructure.AnalyzeAnonymousType(
                directAnonymous,
                semanticModel,
                sourceTypeForNested,
                hintName: propertyName,
                configuration
            );
        }

        // Generalized handling for expressions that result in anonymous types
        // This works for any expression type (ternary operators, method calls, etc.)
        // Step 1: Evaluate the type of the entire expression
        if (nestedStructure is null)
        {
            var expressionTypeInfo = semanticModel.GetTypeInfo(expression);
            var expressionType = expressionTypeInfo.Type ?? expressionTypeInfo.ConvertedType;

            // Step 2: If it is (anonymous) or (anonymous?), we need to generate a DTO for that type
            var underlyingType = expressionType;
            if (
                expressionType is INamedTypeSymbol
                {
                    NullableAnnotation: NullableAnnotation.Annotated
                } namedType
            )
            {
                // For nullable anonymous types, get the underlying type
                underlyingType = namedType.WithNullableAnnotation(NullableAnnotation.NotAnnotated);
            }

            // Check for direct anonymous type
            if (underlyingType != null && underlyingType.IsAnonymousType)
            {
                // Step 3: Find the anonymous type creation expression within this expression
                // It could be anywhere in the syntax tree (e.g., in a ternary branch, method argument, etc.)
                var anonymousCreation = expression
                    .DescendantNodesAndSelf()
                    .OfType<AnonymousObjectCreationExpressionSyntax>()
                    .FirstOrDefault();

                if (anonymousCreation != null)
                {
                    // For generalized expressions with anonymous types, use propertyName as hint
                    nestedStructure = DtoStructure.AnalyzeAnonymousType(
                        anonymousCreation,
                        semanticModel,
                        underlyingType,
                        hintName: propertyName,
                        configuration
                    );
                }
            }
            // Also check for collections containing anonymous types (e.g., IEnumerable<anonymous>)
            // This handles cases like: c.X != null ? c.X.Items.Select(i => new { i.Id }) : null
            else if (
                underlyingType is INamedTypeSymbol collectionType
                && collectionType.TypeArguments.Length > 0
            )
            {
                var elementType = collectionType.TypeArguments[0];
                if (elementType.IsAnonymousType)
                {
                    // Find the anonymous type creation expression within this expression
                    var anonymousCreation = expression
                        .DescendantNodesAndSelf()
                        .OfType<AnonymousObjectCreationExpressionSyntax>()
                        .FirstOrDefault();

                    if (anonymousCreation != null)
                    {
                        // For collections containing anonymous types, use propertyName as hint
                        nestedStructure = DtoStructure.AnalyzeAnonymousType(
                            anonymousCreation,
                            semanticModel,
                            elementType,
                            hintName: propertyName,
                            configuration
                        );
                    }
                }
            }
        }

        // Determine final nullability
        // Special case: When we have a collection with nullable access that will use Enumerable.Empty<T>()
        // as the fallback value, the property should NOT be nullable.
        // Rules for removing nullable from collection types:
        // 1. Expression should NOT contain a ternary operator (if it does, keep nullable)
        // 2. The type must be IEnumerable<T> or derived (List, Array, etc.)
        // 3. The expression uses null-conditional access (?.)
        // 4. The expression contains a Select or SelectMany call
        var shouldBeNullable = isNullable || hasNullableAccess;
        var finalPropertyType = propertyType;

        // Check if this expression contains a ternary operator - if so, keep nullable
        var hasTernaryOperator = expression
            .DescendantNodesAndSelf()
            .OfType<ConditionalExpressionSyntax>()
            .Any();

        // Check if expression contains Select or SelectMany invocation
        var hasSelectOrSelectMany =
            RoslynTypeHelper.ContainsSelectInvocation(expression)
            || RoslynTypeHelper.ContainsSelectManyInvocation(expression);

        // Apply non-nullable for collections that:
        // - ArrayNullabilityRemoval is enabled (default: true)
        // - Are currently marked as nullable (either by type annotation or has null-conditional access)
        // - Don't have a ternary operator (explicit null handling)
        // - Have a Select/SelectMany call (indicates transformation that can use empty collection fallback)
        // - Are a collection type
        // This handles both:
        //   1. foo.bar?.buz.Select(b => new { }) -> IEnumerable<DTO>
        //   2. foo.bar?.buz.Select(b => b.Id).ToList() -> List<int>
        var arrayNullabilityRemoval = configuration?.ArrayNullabilityRemoval ?? true;
        if (
            arrayNullabilityRemoval
            && shouldBeNullable
            && !hasTernaryOperator
            && hasSelectOrSelectMany
            && RoslynTypeHelper.IsCollectionType(propertyType)
        )
        {
            // Collection with Select/SelectMany and no ternary
            // will use empty collection as fallback, so the collection itself should not be nullable
            shouldBeNullable = false;
            // Also remove the nullable annotation from the type symbol if present
            finalPropertyType = RoslynTypeHelper.GetNonNullableType(propertyType) ?? propertyType;
        }

        // Extract documentation from the source symbol
        var documentation = ExtractDocumentation(expression, semanticModel);

        return new DtoProperty(
            Name: propertyName,
            IsNullable: shouldBeNullable,
            OriginalExpression: expression.ToString(),
            OriginalSyntax: expression,
            TypeSymbol: finalPropertyType,
            NestedStructure: nestedStructure,
            Accessibility: accessibility,
            IsNestedFromNamedType: isNestedFromNamedType,
            Documentation: documentation,
            ExplicitNestedDtoType: explicitNestedDtoType,
            ExplicitNestedDtoTypeName: explicitNestedDtoTypeName
        );
    }

    /// <summary>
    /// Checks if an expression contains a Select method call with an anonymous type creation in its lambda body
    /// </summary>
    private static bool ContainsSelectWithAnonymousType(ExpressionSyntax expression)
    {
        var selectInvocation = FindSelectInvocation(expression);
        if (selectInvocation is null || selectInvocation.ArgumentList.Arguments.Count == 0)
            return false;

        var lambdaArg = selectInvocation.ArgumentList.Arguments[0].Expression;
        if (lambdaArg is not LambdaExpressionSyntax lambda)
            return false;

        // Check if the lambda body is an anonymous object creation
        return lambda.Body is AnonymousObjectCreationExpressionSyntax;
    }

    /// <summary>
    /// Helper method to extract type and nullability annotation from a symbol
    /// </summary>
    private static (ITypeSymbol Type, NullableAnnotation NullableAnnotation) GetTypeInfoFromSymbol(
        ISymbol symbol
    )
    {
        var type = symbol switch
        {
            IPropertySymbol prop => prop.Type,
            IFieldSymbol field => field.Type,
            _ => throw new ArgumentException($"Unsupported symbol type: {symbol.GetType().Name}"),
        };
        return (type, type.NullableAnnotation);
    }

    /// <summary>
    /// Determines if a collection invocation should be forced to be non-nullable
    /// </summary>
    private static bool ShouldForceNonNullableCollection(InvocationExpressionSyntax invocation)
    {
        // Check if there's a nullable access operator on the collection itself
        var hasNullableOnCollection = HasNullableAccess(invocation);

        // If there's no nullable access on the collection itself and it's a collection creation method,
        // the collection should not be nullable even if it contains nullable elements
        return !hasNullableOnCollection && IsCollectionCreationMethod(invocation);
    }

    /// <summary>
    /// Collection creation method names that produce non-nullable collections
    /// </summary>
    private static readonly HashSet<string> CollectionCreationMethods =
    [
        "ToList",
        "ToArray",
        "ToHashSet",
        "ToImmutableList",
        "ToImmutableArray",
        "ToImmutableHashSet",
        "ToImmutableSet",
        "ToDictionary",
        "ToImmutableDictionary",
        "ToLookup",
        "AsEnumerable",
        "AsQueryable",
    ];

    /// <summary>
    /// Checks if an invocation is a collection creation method like ToList(), ToArray(), etc.
    /// </summary>
    private static bool IsCollectionCreationMethod(InvocationExpressionSyntax invocation)
    {
        if (invocation.Expression is MemberAccessExpressionSyntax memberAccess)
        {
            var methodName = memberAccess.Name.Identifier.Text;
            return CollectionCreationMethods.Contains(methodName);
        }
        return false;
    }

    /// <summary>
    /// Syntax-based heuristic to determine if null check should be generated.
    /// This is a fallback for when Roslyn's NullableAnnotation is unreliable (e.g., in Visual Studio).
    /// see https://github.com/arika0093/Linqraft/issues/22
    /// </summary>
    private static bool ShouldGenerateNullCheckFromSyntax(ExpressionSyntax expression)
    {
        return NullConditionalHelper.ShouldGenerateNullCheckFromSyntax(expression);
    }

    private static bool HasNullableAccess(ExpressionSyntax expression)
    {
        return NullConditionalHelper.HasNullConditionalAccess(expression);
    }

    private static InvocationExpressionSyntax? FindSelectInvocation(ExpressionSyntax expression)
    {
        return LinqMethodHelper.FindLinqMethodInvocation(expression, "Select");
    }

    private static InvocationExpressionSyntax? FindSelectManyInvocation(ExpressionSyntax expression)
    {
        return LinqMethodHelper.FindLinqMethodInvocation(expression, "SelectMany");
    }

    private static InvocationExpressionSyntax? FindSelectExprInvocation(ExpressionSyntax expression)
    {
        return LinqMethodHelper.FindLinqMethodInvocation(expression, "SelectExpr");
    }

    /// <summary>
    /// Extracts documentation information from the source symbol of an expression
    /// </summary>
    private static DocumentationCommentHelper.DocumentationInfo? ExtractDocumentation(
        ExpressionSyntax expression,
        SemanticModel semanticModel
    )
    {
        // Build source reference from expression (converting lambda param to source type name)
        var sourceReference = BuildSourceReference(expression, semanticModel);

        DocumentationCommentHelper.DocumentationInfo? baseDocumentation = null;

        // Check if this is an invocation expression containing Select/SelectMany
        // For these cases, extract documentation from the collection property
        var selectInvocation = FindSelectInvocation(expression);
        var selectManyInvocation = FindSelectManyInvocation(expression);

        if (selectInvocation is not null || selectManyInvocation is not null)
        {
            // For Select/SelectMany expressions, get documentation from the collection property
            var (sourceSymbol, containingTypeName) = GetSourceSymbolFromSelectExpression(
                selectInvocation ?? selectManyInvocation!,
                semanticModel
            );

            if (sourceSymbol is IPropertySymbol propertySymbol)
            {
                baseDocumentation = DocumentationCommentHelper.GetPropertyDocumentation(
                    propertySymbol,
                    containingTypeName
                );
            }
            else if (sourceSymbol is IFieldSymbol fieldSymbol)
            {
                baseDocumentation = DocumentationCommentHelper.GetFieldDocumentation(
                    fieldSymbol,
                    containingTypeName
                );
            }
        }
        else if (IsSimpleMemberAccessExpression(expression))
        {
            // Only extract symbol documentation for simple member access expressions
            // For complex expressions (binary, invocations with nested selects, etc.), just use source reference
            var (sourceSymbol, containingTypeName) = GetSourceSymbolFromExpression(
                expression,
                semanticModel
            );

            // Extract documentation from the source symbol
            if (sourceSymbol is IPropertySymbol propertySymbol)
            {
                baseDocumentation = DocumentationCommentHelper.GetPropertyDocumentation(
                    propertySymbol,
                    containingTypeName
                );
            }
            else if (sourceSymbol is IFieldSymbol fieldSymbol)
            {
                baseDocumentation = DocumentationCommentHelper.GetFieldDocumentation(
                    fieldSymbol,
                    containingTypeName
                );
            }
        }

        // If we have documentation, update with the full source reference
        if (baseDocumentation != null)
        {
            return baseDocumentation with
            {
                SourceReference = sourceReference ?? baseDocumentation.SourceReference,
            };
        }

        // If no source symbol found, return just the source reference
        if (!string.IsNullOrEmpty(sourceReference))
        {
            return new DocumentationCommentHelper.DocumentationInfo
            {
                SourceReference = sourceReference,
            };
        }

        return null;
    }

    /// <summary>
    /// Determines if an expression is a simple member access (e.g., s.Name, s.Child?.Name)
    /// Returns false for complex expressions like binary expressions, invocations, etc.
    /// </summary>
    private static bool IsSimpleMemberAccessExpression(ExpressionSyntax expression)
    {
        // Simple member access: s.Name
        if (expression is MemberAccessExpressionSyntax)
            return true;

        // Conditional member access: s.Child?.Name (wrapped in ConditionalAccessExpression)
        if (expression is ConditionalAccessExpressionSyntax)
            return true;

        // All other types (binary, invocation, etc.) are complex
        return false;
    }

    /// <summary>
    /// Gets the source symbol from an expression (the property or field being accessed).
    ///
    /// IMPORTANT: The order of checks matters for correct documentation extraction:
    ///
    /// 1. Conditional access expressions (e.g., oi.Product?.Name) must be checked FIRST because:
    ///    - The syntax tree for "oi.Product?.Name" is: ConditionalAccessExpression containing:
    ///      - MemberAccessExpression: oi.Product
    ///      - MemberBindingExpression: .Name
    ///    - If we check MemberAccessExpression first, we'd get "oi.Product" which is WRONG
    ///    - We need to get MemberBindingExpression ".Name" to get the correct documentation
    ///
    /// 2. Direct member access (e.g., s.Name) is checked second for non-conditional cases
    /// </summary>
    private static (ISymbol? Symbol, string? ContainingTypeName) GetSourceSymbolFromExpression(
        ExpressionSyntax expression,
        SemanticModel semanticModel
    )
    {
        // Check for conditional access first (e.g., s.Child?.Name, oi.Product?.Name)
        // For conditional access, we need to get the last MemberBindingExpressionSyntax (the .Name part)
        // NOT the MemberAccessExpressionSyntax which would give us the wrong property (s.Child or oi.Product)
        var conditionalAccess = expression
            .DescendantNodesAndSelf()
            .OfType<ConditionalAccessExpressionSyntax>()
            .LastOrDefault();

        if (conditionalAccess != null)
        {
            // Get the last member binding expression (the part after ?.)
            // For oi.Product?.Name, this gives us .Name
            var memberBinding = conditionalAccess
                .DescendantNodes()
                .OfType<MemberBindingExpressionSyntax>()
                .LastOrDefault();

            if (memberBinding != null)
            {
                var symbolInfo = semanticModel.GetSymbolInfo(memberBinding);
                return (symbolInfo.Symbol, symbolInfo.Symbol?.ContainingType?.Name);
            }
        }

        // For direct member access (e.g., s.Name)
        // Navigate through the expression to find the leaf member access
        var leafMemberAccess = expression
            .DescendantNodesAndSelf()
            .OfType<MemberAccessExpressionSyntax>()
            .LastOrDefault();

        if (leafMemberAccess != null)
        {
            var symbolInfo = semanticModel.GetSymbolInfo(leafMemberAccess);
            var symbol = symbolInfo.Symbol;
            var containingTypeName = symbol?.ContainingType?.Name;

            // For chained access, we want the type name to be the containing type of the accessed member
            var fullContainingTypeName = GetFullContainingTypeName(leafMemberAccess, semanticModel);

            return (symbol, fullContainingTypeName ?? containingTypeName);
        }

        return (null, null);
    }

    /// <summary>
    /// Gets the source symbol from a Select/SelectMany invocation expression.
    /// Extracts documentation from the collection property that is being selected from.
    ///
    /// Handles the following patterns:
    /// - s.OrderItems.Select(...)           -> gets documentation from s.OrderItems
    /// - s.Items?.Select(...)               -> gets documentation from s.Items
    /// - s.Parent.Children.Select(...)      -> gets documentation from s.Parent.Children
    /// - items.Select(...) (local variable) -> returns null (no meaningful documentation)
    /// </summary>
    private static (
        ISymbol? Symbol,
        string? ContainingTypeName
    ) GetSourceSymbolFromSelectExpression(
        InvocationExpressionSyntax selectInvocation,
        SemanticModel semanticModel
    )
    {
        // For s.OrderItems.Select(...), we want to get documentation from OrderItems property
        // The selectInvocation.Expression is: s.OrderItems.Select
        // We need to find the member access before the .Select call
        if (selectInvocation.Expression is MemberAccessExpressionSyntax selectMemberAccess)
        {
            // selectMemberAccess.Expression is: s.OrderItems
            // This could be a simple member access or a chained access
            if (selectMemberAccess.Expression is MemberAccessExpressionSyntax collectionAccess)
            {
                var symbolInfo = semanticModel.GetSymbolInfo(collectionAccess);
                return (symbolInfo.Symbol, symbolInfo.Symbol?.ContainingType?.Name);
            }

            // For nullable access like s.Items?.Select(...)
            // selectMemberAccess.Expression would be s.Items
            if (selectMemberAccess.Expression is ConditionalAccessExpressionSyntax)
            {
                // The collection is before the ?.
                var conditionalAccess = (ConditionalAccessExpressionSyntax)
                    selectMemberAccess.Expression;
                if (
                    conditionalAccess.Expression
                    is MemberAccessExpressionSyntax nullableCollectionAccess
                )
                {
                    var symbolInfo = semanticModel.GetSymbolInfo(nullableCollectionAccess);
                    return (symbolInfo.Symbol, symbolInfo.Symbol?.ContainingType?.Name);
                }
            }

            // For cases like items.Select(...) where items is an identifier
            if (selectMemberAccess.Expression is IdentifierNameSyntax)
            {
                // This is a variable like items.Select(...), not a property access
                // We can't get meaningful documentation from a local variable
                return (null, null);
            }
        }

        // For conditional access like s.Items?.Select(...)
        // The WhenNotNull part contains the .Select call via MemberBinding
        if (selectInvocation.Expression is MemberBindingExpressionSyntax)
        {
            // We need to look at the parent conditional access to find the collection
            var parentConditionalAccess = selectInvocation
                .Ancestors()
                .OfType<ConditionalAccessExpressionSyntax>()
                .FirstOrDefault();

            if (
                parentConditionalAccess?.Expression is MemberAccessExpressionSyntax collectionAccess
            )
            {
                var symbolInfo = semanticModel.GetSymbolInfo(collectionAccess);
                return (symbolInfo.Symbol, symbolInfo.Symbol?.ContainingType?.Name);
            }
        }

        return (null, null);
    }

    /// <summary>
    /// Gets the full containing type name from a member access expression path
    /// </summary>
    private static string? GetFullContainingTypeName(
        MemberAccessExpressionSyntax memberAccess,
        SemanticModel semanticModel
    )
    {
        // Get the type of the expression being accessed
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        var expressionType = typeInfo.Type;

        if (expressionType != null)
        {
            // Remove nullable annotation for the type name
            var nonNullableType =
                RoslynTypeHelper.GetNonNullableType(expressionType) ?? expressionType;
            return nonNullableType.Name;
        }

        return null;
    }

    /// <summary>
    /// Builds the source reference string from an expression
    /// Converts lambda parameter to source type name and handles chained expressions
    /// </summary>
    private static string? BuildSourceReference(
        ExpressionSyntax expression,
        SemanticModel semanticModel
    )
    {
        // First, normalize the expression string: remove comments and normalize whitespace
        var expressionStr = NormalizeExpressionString(expression.ToString());

        // Handle common patterns:
        // 1. Simple member access: s.Id -> SourceType.Id
        // 2. Chained access: s.Child?.Id -> SourceType.Child?.Id
        // 3. Linq chain: s.Children.Select(...).ToList() -> SourceType.Children.Select(...).ToList()

        // Find all identifier names that could be lambda parameters
        var firstIdentifier = expression
            .DescendantNodesAndSelf()
            .OfType<IdentifierNameSyntax>()
            .FirstOrDefault();

        if (firstIdentifier == null)
            return SimplifySourceReference(expressionStr);

        // Check if this identifier is a lambda parameter
        var symbolInfo = semanticModel.GetSymbolInfo(firstIdentifier);
        if (
            symbolInfo.Symbol is IParameterSymbol parameterSymbol
            && parameterSymbol.ContainingSymbol is IMethodSymbol methodSymbol
            && methodSymbol.MethodKind == MethodKind.LambdaMethod
        )
        {
            // This is a lambda parameter, get the type name to replace it
            var sourceTypeName = parameterSymbol.Type.Name;
            var paramName = firstIdentifier.Identifier.Text;

            // Replace all occurrences of the lambda parameter with the type name
            // Match: paramName followed by . or ?. but not as part of another identifier
            var pattern = $@"\b{System.Text.RegularExpressions.Regex.Escape(paramName)}(?=[.?])";
            var result = System.Text.RegularExpressions.Regex.Replace(
                expressionStr,
                pattern,
                sourceTypeName
            );

            // If replacement happened, simplify and return
            if (result != expressionStr)
            {
                return SimplifySourceReference(result);
            }

            // If the expression is just the parameter, return the type name
            if (expressionStr == paramName)
            {
                return sourceTypeName;
            }
        }

        // Simplify complex expressions (Select, SelectMany, Where, etc.)
        return SimplifySourceReference(expressionStr);
    }

    /// <summary>
    /// Normalizes an expression string by removing comments and collapsing whitespace
    /// </summary>
    private static string NormalizeExpressionString(string expressionStr)
    {
        // Remove single-line comments (// comment)
        var result = System.Text.RegularExpressions.Regex.Replace(
            expressionStr,
            @"//.*$",
            "",
            System.Text.RegularExpressions.RegexOptions.Multiline
        );

        // Remove multi-line comments (/* comment */)
        result = System.Text.RegularExpressions.Regex.Replace(
            result,
            @"/\*.*?\*/",
            "",
            System.Text.RegularExpressions.RegexOptions.Singleline
        );

        // Normalize whitespace: replace multiple whitespace chars with a single space
        result = System.Text.RegularExpressions.Regex.Replace(result, @"\s+", " ");

        return result.Trim();
    }

    /// <summary>
    /// Simplifies a source reference by abbreviating any method calls with arguments
    /// </summary>
    private static string SimplifySourceReference(string expressionStr)
    {
        // Abbreviate any method call with arguments using regex pattern: .MethodName(args) -> .MethodName(...)
        // This matches any method call pattern like .Select(x => ...), .Where(...), .CustomMethod(arg1, arg2), etc.
        var result = AbbreviateAllMethodCalls(expressionStr);
        return result;
    }

    /// <summary>
    /// Abbreviates all method calls with arguments (any method pattern like .MethodName(args))
    /// Also abbreviates generic type arguments like .MethodName&lt;Type1, Type2&gt;(args) -> .MethodName(...)
    /// </summary>
    private static string AbbreviateAllMethodCalls(string input)
    {
        var result = new System.Text.StringBuilder();
        int pos = 0;

        while (pos < input.Length)
        {
            // Find the next method call pattern: .MethodName(
            // Method name must start with a letter and contain only letters/digits
            var dotIndex = input.IndexOf('.', pos);
            if (dotIndex < 0 || dotIndex >= input.Length - 2)
            {
                result.Append(input.Substring(pos));
                break;
            }

            // Check if this is a method call (letter follows the dot)
            var nextChar = input[dotIndex + 1];
            if (!char.IsLetter(nextChar))
            {
                result.Append(input.Substring(pos, dotIndex - pos + 1));
                pos = dotIndex + 1;
                continue;
            }

            // Find the end of the method name
            var methodNameEnd = dotIndex + 1;
            while (
                methodNameEnd < input.Length
                && (char.IsLetterOrDigit(input[methodNameEnd]) || input[methodNameEnd] == '_')
            )
            {
                methodNameEnd++;
            }

            var methodName = input.Substring(dotIndex + 1, methodNameEnd - dotIndex - 1);

            // Skip generic type arguments if present
            methodNameEnd = SkipGenericTypeArguments(input, methodNameEnd);

            // Check if there's an opening parenthesis after the method name (and optional generic args)
            if (methodNameEnd >= input.Length || input[methodNameEnd] != '(')
            {
                // Not a method call, just a property access
                result.Append(input.Substring(pos, methodNameEnd - pos));
                pos = methodNameEnd;
                continue;
            }

            // This is a method call with arguments
            // Append everything before the method call
            result.Append(input.Substring(pos, dotIndex - pos));

            // Find the matching closing parenthesis
            var parenStart = methodNameEnd;
            var depth2 = 1;
            var endIndex = parenStart + 1;

            while (endIndex < input.Length && depth2 > 0)
            {
                if (input[endIndex] == '(')
                    depth2++;
                else if (input[endIndex] == ')')
                    depth2--;
                endIndex++;
            }

            // Check if the method has arguments (not just empty parentheses)
            var argsLength = Math.Max(0, endIndex - parenStart - 2);
            var argsContent =
                argsLength > 0 ? input.Substring(parenStart + 1, argsLength).Trim() : "";
            if (string.IsNullOrEmpty(argsContent))
            {
                // Empty parentheses, keep as is
                result.Append($".{methodName}()");
            }
            else
            {
                // Has arguments, abbreviate (including any generic type arguments)
                result.Append($".{methodName}(...)");
            }
            pos = endIndex;
        }

        return result.ToString();
    }

    /// <summary>
    /// Skips generic type arguments in a string if present at the given position.
    /// Returns the position after the generic type arguments, or the original position if none found.
    /// </summary>
    /// <param name="input">The input string</param>
    /// <param name="startPos">The position to start checking for generic arguments</param>
    /// <returns>The position after the generic type arguments</returns>
    private static int SkipGenericTypeArguments(string input, int startPos)
    {
        // Check for generic type arguments (<Type1, Type2, ...>)
        if (startPos < input.Length && input[startPos] == '<')
        {
            // Find the matching closing angle bracket
            var depth = 1;
            var pos = startPos + 1;

            while (pos < input.Length && depth > 0)
            {
                if (input[pos] == '<')
                    depth++;
                else if (input[pos] == '>')
                    depth--;
                pos++;
            }

            return pos;
        }

        return startPos;
    }
}
