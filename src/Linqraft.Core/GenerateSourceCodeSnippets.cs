using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Linqraft.Core.Formatting;
using Microsoft.CodeAnalysis;

namespace Linqraft.Core;

public static class GenerateSourceCodeSnippets
{
    // Export all source codes
    public static void ExportAllConstantSnippets(
        IncrementalGeneratorPostInitializationContext context
    )
    {
        context.AddSource("EmbeddedAttribute.g.cs", EmbeddedAttribute);
        context.AddSource("InterceptsLocationAttribute.g.cs", InterceptsLocationAttribute);
        context.AddSource("SelectExprExtensions.g.cs", SelectExprExtensions);
        context.AddSource(
            "LinqraftAutoGeneratedDtoAttribute.g.cs",
            LinqraftAutoGeneratedDtoAttribute
        );
        context.AddSource(
            "LinqraftMappingGenerateAttribute.g.cs",
            LinqraftMappingGenerateAttribute
        );
        context.AddSource("LinqraftMappingDeclare.g.cs", LinqraftMappingDeclare);
    }

    // Generate expression and headers
    public static string BuildExprCodeSnippetsWithHeaders(
        List<string> expressions,
        List<string> staticFields,
        string? dtoCode = null
    )
    {
        var dtoPart = string.IsNullOrWhiteSpace(dtoCode)
            ? string.Empty
            : $"{CodeFormatter.DefaultNewLine}{dtoCode}";

        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{BuildExprCodeSnippets(expressions, staticFields)}}{{dtoPart}}
            """;
    }

    // Generate expression part
    public static string BuildExprCodeSnippets(List<string> expressions, List<string> staticFields)
    {
        var fieldsPart =
            staticFields.Count > 0
                ? CodeFormatter.IndentCode(
                    string.Join(CodeFormatter.DefaultNewLine, staticFields),
                    CodeFormatter.IndentSize * 2
                ) + CodeFormatter.DefaultNewLine
                : "";

        var indentedExpr = CodeFormatter.IndentCode(
            string.Join(CodeFormatter.DefaultNewLine, expressions),
            CodeFormatter.IndentSize * 2
        );
        return $$"""
            {{GenerateHeaderUsingPart}}
            namespace Linqraft
            {
                file static partial class GeneratedExpression
                {
            {{fieldsPart}}{{indentedExpr}}
                }
            }
            """;
    }

    // Generate all DTOs in a single shared source file with global deduplication
    public static string BuildGlobalDtoCodeSnippet(
        List<GenerateDtoClassInfo> allDtoClassInfos,
        LinqraftConfiguration configuration
    )
    {
        // Deduplicate DTOs globally by FullName
        var globallyUniqueDtos = allDtoClassInfos
            .GroupBy(c => c.FullName)
            .Select(g => g.First())
            .ToList();

        if (globallyUniqueDtos.Count == 0)
        {
            return string.Empty;
        }

        var dtoSourceCode = BuildDtoCodeSnippetsGroupedByNamespace(
            globallyUniqueDtos,
            configuration
        );

        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{dtoSourceCode}}
            """;
    }

    // Generate DTO part
    public static string BuildDtoCodeSnippets(List<string> dtoClasses, string namespaceName)
    {
        if (string.IsNullOrEmpty(namespaceName))
        {
            // Generate DTOs in global namespace (no namespace wrapper)
            return string.Join(CodeFormatter.DefaultNewLine, dtoClasses);
        }
        else
        {
            // Generate DTOs in the specified namespace
            var indentedClasses = CodeFormatter.IndentCode(
                string.Join(CodeFormatter.DefaultNewLine, dtoClasses),
                CodeFormatter.IndentSize
            );
            return $$"""
                namespace {{namespaceName}}
                {
                {{indentedClasses}}
                }
                """;
        }
    }

    // Generate DTO part with DTOs grouped by their namespace.
    public static string BuildDtoCodeSnippetsGroupedByNamespace(
        List<GenerateDtoClassInfo> dtoClassInfos,
        LinqraftConfiguration configuration
    )
    {
        // Group DTOs by namespace
        var dtosByNamespace = dtoClassInfos
            .GroupBy(c => c.Namespace)
            .OrderBy(g => g.Key) // Sort for consistent output
            .ToList();

        var result = new List<string>();

        foreach (var group in dtosByNamespace)
        {
            var namespaceName = group.Key;
            var dtoClasses = group.Select(c => c.BuildCode(configuration)).ToList();

            if (string.IsNullOrEmpty(namespaceName))
            {
                // Generate DTOs in global namespace (no namespace wrapper)
                result.Add(string.Join(CodeFormatter.DefaultNewLine, dtoClasses));
            }
            else
            {
                // Generate DTOs in the specified namespace
                var indentedClasses = CodeFormatter.IndentCode(
                    string.Join(CodeFormatter.DefaultNewLine, dtoClasses),
                    CodeFormatter.IndentSize
                );
                result.Add(
                    $$"""
                    namespace {{namespaceName}}
                    {
                    {{indentedClasses}}
                    }
                    """
                );
            }
        }

        return string.Join(CodeFormatter.DefaultNewLine, result);
    }

    // Attributes for DTO classes
    public static string BuildDtoCodeAttributes()
    {
        return """
            [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
            [global::Linqraft.LinqraftAutoGeneratedDtoAttribute]
            """;
    }

    [StringSyntax("csharp")]
    private const string EmbeddedAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        namespace Microsoft.CodeAnalysis
        {
            internal sealed partial class EmbeddedAttribute : global::System.Attribute
            {
            }
        }
        """;

    [StringSyntax("csharp")]
    public const string InterceptsLocationAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace System.Runtime.CompilerServices
        {
            [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            [EmbeddedAttribute]
            internal sealed class InterceptsLocationAttribute : Attribute
            {
                public InterceptsLocationAttribute(int version, string data)
                {
                    Version = version;
                    Data = data;
                }

                public int Version { get; }
                public string Data { get; }
            }
        }
        """;

    /// <summary>
    /// Attribute to mark auto-generated DTO classes.
    /// This attribute is used by Linqraft analyzers to detect explicit usage of auto-generated DTOs.
    /// </summary>
    [StringSyntax("csharp")]
    public const string LinqraftAutoGeneratedDtoAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace Linqraft
        {
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            [EmbeddedAttribute]
            internal sealed class LinqraftAutoGeneratedDtoAttribute : Attribute
            {
            }
        }
        """;

    /// <summary>
    /// Attribute to mark methods for Linqraft mapping generation.
    /// This attribute is used to generate extension methods instead of using interceptors,
    /// which is useful for EFCore query (pre)compilation and other scenarios where interceptors
    /// are not supported.
    /// </summary>
    [StringSyntax("csharp")]
    public const string LinqraftMappingGenerateAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace Linqraft
        {
            /// <summary>
            /// Marks a method or class for Linqraft mapping generation. 
            /// When used on a method: The method must be in a static partial class and contain a SelectExpr call.
            /// When used on a class: The class must inherit from LinqraftMappingDeclare&lt;T&gt;.
            /// Linqraft will generate an extension method with the specified name that contains the compiled Select expression.
            /// This is useful for EFCore query (pre)compilation support where interceptors cannot be used.
            /// </summary>
            [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
            [EmbeddedAttribute]
            internal sealed class LinqraftMappingGenerateAttribute : Attribute
            {
                /// <summary>
                /// Initializes a new instance of the LinqraftMappingGenerateAttribute class.
                /// </summary>
                /// <param name="methodName">The name of the extension method to generate.</param>
                public LinqraftMappingGenerateAttribute(string methodName)
                {
                    MethodName = methodName;
                }

                /// <summary>
                /// Gets the name of the extension method to generate.
                /// </summary>
                public string MethodName { get; }
            }
        }
        """;

    /// <summary>
    /// Abstract base class for declaring Linqraft mappings using a helper class pattern.
    /// This provides a simpler alternative to manually defining static partial classes.
    /// </summary>
    [StringSyntax("csharp")]
    public const string LinqraftMappingDeclare = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.Linq;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace Linqraft
        {
            /// <summary>
            /// Abstract base class for declaring Linqraft mappings.
            /// Inherit from this class and override DefineMapping to define your projection mapping.
            /// The source generator will create an extension method class with the mapping logic.
            /// </summary>
            /// <typeparam name="T">The source entity type to project from.</typeparam>
            [EmbeddedAttribute]
            public abstract class LinqraftMappingDeclare<T>
            {
                /// <summary>
                /// Override this method to define your projection mapping using SelectExpr.
                /// This method is never called at runtime - it's only analyzed by the source generator.
                /// </summary>
                protected abstract void DefineMapping();

                /// <summary>
                /// Dummy source queryable for use in DefineMapping method with SelectExpr.
                /// This property is never accessed at runtime - it exists only for source generation.
                /// </summary>
                protected IQueryable<T> Source => System.Linq.Enumerable.Empty<T>().AsQueryable();
            }
        }
        """;

    [StringSyntax("csharp")]
    public const string SelectExprExtensions = $$""""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        {{GenerateHeaderUsingPart}}

        /// <summary>
        /// Dummy expression methods for Linqraft to compile correctly.
        /// </summary>
        internal static class SelectExprExtensions
        {
            /// <summary>
            /// Create select expression method, usable nullable operators, and generate instance DTOs.
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, usable nullable operators, and generate instance DTOs.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector, object capture)
                where TIn : class => throw InvalidException;

            private static Exception InvalidException => new System.InvalidOperationException(SelectExprErrorMessage); 

            private const string SelectExprErrorMessage = """
        {{SelectExprErrorMessage}}
        """;
        }
        """";

    private const string SelectExprErrorMessage = """
        This is a dummy method for Linqraft source generator and should not be called directly.
        If you see this message, it is likely due to a bug. Please contact us via the Linqraft Issue page.
        https://github.com/arika0093/Linqraft/issues
        """;

    private static string GenerateCommentHeaderPart()
    {
#if DEBUG
        var now = DateTime.Now;
        var buildDate = BuildDateTimeAttribute.GetBuildDateTimeUtc()?.ToLocalTime();
        var buildDateString = buildDate?.ToString("yyyy-MM-dd HH:mm:ss") ?? "Unknown";
        return $"""
            // <auto-generated>
            // This file is auto-generated by Linqraft.
            //   Linqraft Version  : {ThisAssembly.AssemblyInformationalVersion}
            //   Linqraft Build at : {buildDateString}
            //   Code Generated at : {now:yyyy-MM-dd HH:mm:ss}
            // </auto-generated>
            """;
#else
        return CommentHeaderPartOnProd;
#endif
    }

    private const string CommentHeaderPartOnProd = $"""
        // <auto-generated>
        // This file is auto-generated by Linqraft (ver. {ThisAssembly.AssemblyVersion})
        // </auto-generated>
        """;

    private const string GenerateHeaderFlagsPart = """
        #nullable enable
        #pragma warning disable IDE0060
        #pragma warning disable CS8601
        #pragma warning disable CS8602
        #pragma warning disable CS8603
        #pragma warning disable CS8604
        #pragma warning disable CS8618
        """;

    private const string GenerateHeaderUsingPart = """
        using System;
        using System.Linq;
        using System.Linq.Expressions;
        using System.Collections.Generic;
        using System.Collections.Immutable;
        """;

    // OverloadPriorityAttribute is usable C# 13 or later.
    // but we cannot detect C# language version in source generator,
    // so we use .NET version as a proxy here.
    private const string OverloadPriorityAttribute = """
        #if NET9_0_OR_GREATER
            [System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute(-1)]
        #endif
        """;

    /// <summary>
    /// Generates a mapping class wrapper with the specified methods
    /// </summary>
    public static string BuildMappingClassCode(
        INamedTypeSymbol containingClass,
        List<string> methods
    )
    {
        var namespaceName = containingClass.ContainingNamespace?.ToDisplayString();
        var hasNamespace = namespaceName != null && namespaceName != "<global namespace>";
        var firstIndent = CodeFormatter.Indent(hasNamespace ? 1 : 0);
        var indent = CodeFormatter.Indent(1);

        // Determine accessibility - use the class's declared accessibility
        var accessibility = containingClass.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            _ => "internal",
        };

        var methodsPart = methods
            .Select(method =>
                method
                    .Split('\n')
                    .Select(m => $"{firstIndent}{indent}{m}")
                    .Aggregate((a, b) => $"{a}\n{b}")
            )
            .Aggregate((a, b) => $"{a}\n{b}");
        var classPart = $$"""
            {{firstIndent}}{{accessibility}} static partial class {{containingClass.Name}}
            {{firstIndent}}{
            {{methodsPart}}
            {{firstIndent}}}
            """;
        var classWithNamespacePart = hasNamespace
            ? $$"""
                namespace {{namespaceName}}
                {
                {{classPart}}
                }
                """
            : classPart;

        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{GenerateHeaderUsingPart}}
            {{classWithNamespacePart}}
            """;
    }

    /// <summary>
    /// Builds mapping class code with a custom class name (for LinqraftMappingDeclare pattern)
    /// </summary>
    public static string BuildMappingClassCode(
        INamedTypeSymbol containingClass,
        List<string> methods,
        string customClassName
    )
    {
        var namespaceName = containingClass.ContainingNamespace?.ToDisplayString();
        var hasNamespace = namespaceName != null && namespaceName != "<global namespace>";
        var firstIndent = CodeFormatter.Indent(hasNamespace ? 1 : 0);
        var indent = CodeFormatter.Indent(1);

        // Determine accessibility - use the class's declared accessibility
        var accessibility = containingClass.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            _ => "internal",
        };

        var methodsPart = methods
            .Select(method =>
                method
                    .Split('\n')
                    .Select(m => $"{firstIndent}{indent}{m}")
                    .Aggregate((a, b) => $"{a}\n{b}")
            )
            .Aggregate((a, b) => $"{a}\n{b}");
        var classPart = $$"""
            {{firstIndent}}{{accessibility}} static partial class {{customClassName}}
            {{firstIndent}}{
            {{methodsPart}}
            {{firstIndent}}}
            """;
        var classWithNamespacePart = hasNamespace
            ? $$"""
                namespace {{namespaceName}}
                {
                {{classPart}}
                }
                """
            : classPart;

        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{GenerateHeaderUsingPart}}
            {{classWithNamespacePart}}
            """;
    }

    /// <summary>
    /// Generates an extension method for a mapping method (without interceptor)
    /// </summary>
    public static string GenerateMappingMethod(SelectExprInfo info)
    {
        if (info.MappingMethodName == null || info.MappingContainingClass == null)
            return "";

        // Analyze the DTO structure
        var dtoStructure = info.GenerateDtoStructure();

        if (dtoStructure == null || dtoStructure.Properties.Count == 0)
            return "";

        // Get the method name from the mapping info
        var methodName = info.MappingMethodName;

        // Get the DTO fully qualified name with global:: prefix
        var dtoFullName = info.GetParentDtoFullName(dtoStructure);

        // Get return type prefix (IQueryable or IEnumerable)
        var returnTypePrefix = info.GetReturnTypePrefix();

        var sourceTypeFullName = dtoStructure.SourceTypeFullName;

        // Build the extension method
        var sb = new System.Text.StringBuilder();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Extension method generated by LinqraftMappingGenerate attribute");
        sb.AppendLine($"/// </summary>");

        // Generate method signature as an extension method
        sb.AppendLine($"internal static {returnTypePrefix}<{dtoFullName}> {methodName}(");
        sb.AppendLine($"    this {returnTypePrefix}<{sourceTypeFullName}> source)");
        sb.AppendLine($"{{");
        sb.AppendLine($"    return source.Select({info.LambdaParameterName} => new {dtoFullName}");
        sb.AppendLine($"    {{");

        // Generate property assignments
        foreach (var prop in dtoStructure.Properties)
        {
            var assignment = info.GeneratePropertyAssignment(prop, 8);
            sb.AppendLine($"        {prop.Name} = {assignment},");
        }

        sb.AppendLine($"    }});");
        sb.AppendLine($"}}");
        sb.AppendLine();

        return sb.ToString();
    }
}
