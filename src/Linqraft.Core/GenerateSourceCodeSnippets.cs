using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Linqraft.Core.Formatting;
using Microsoft.CodeAnalysis;

namespace Linqraft.Core;

public static class GenerateSourceCodeSnippets
{
    // Export all source codes
    public static void ExportAllConstantSnippets(
        IncrementalGeneratorPostInitializationContext context
    )
    {
        context.AddSource("EmbeddedAttribute.g.cs", EmbeddedAttribute);
        context.AddSource("InterceptsLocationAttribute.g.cs", InterceptsLocationAttribute);
        context.AddSource("SelectExprExtensions.g.cs", SelectExprExtensions);
        context.AddSource(
            "LinqraftAutoGeneratedDtoAttribute.g.cs",
            LinqraftAutoGeneratedDtoAttribute
        );
        context.AddSource(
            "LinqraftMappingGenerateAttribute.g.cs",
            LinqraftMappingGenerateAttribute
        );
    }

    // Generate expression and headers
    public static string BuildExprCodeSnippetsWithHeaders(
        List<string> expressions,
        List<string> staticFields
    )
    {
        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{BuildExprCodeSnippets(expressions, staticFields)}}
            """;
    }

    // Generate expression part
    public static string BuildExprCodeSnippets(List<string> expressions, List<string> staticFields)
    {
        var fieldsPart =
            staticFields.Count > 0
                ? CodeFormatter.IndentCode(
                    string.Join(CodeFormatter.DefaultNewLine, staticFields),
                    CodeFormatter.IndentSize * 2
                ) + CodeFormatter.DefaultNewLine
                : "";

        var indentedExpr = CodeFormatter.IndentCode(
            string.Join(CodeFormatter.DefaultNewLine, expressions),
            CodeFormatter.IndentSize * 2
        );
        return $$"""
            {{GenerateHeaderUsingPart}}
            namespace Linqraft
            {
                file static partial class GeneratedExpression
                {
            {{fieldsPart}}{{indentedExpr}}
                }
            }
            """;
    }

    // Generate all DTOs in a single shared source file with global deduplication
    public static string BuildGlobalDtoCodeSnippet(
        List<GenerateDtoClassInfo> allDtoClassInfos,
        LinqraftConfiguration configuration
    )
    {
        // Deduplicate DTOs globally by FullName
        var globallyUniqueDtos = allDtoClassInfos
            .GroupBy(c => c.FullName)
            .Select(g => g.First())
            .ToList();

        if (globallyUniqueDtos.Count == 0)
        {
            return string.Empty;
        }

        var dtoSourceCode = BuildDtoCodeSnippetsGroupedByNamespace(
            globallyUniqueDtos,
            configuration
        );

        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{dtoSourceCode}}
            """;
    }

    // Generate DTO part
    public static string BuildDtoCodeSnippets(List<string> dtoClasses, string namespaceName)
    {
        if (string.IsNullOrEmpty(namespaceName))
        {
            // Generate DTOs in global namespace (no namespace wrapper)
            return string.Join(CodeFormatter.DefaultNewLine, dtoClasses);
        }
        else
        {
            // Generate DTOs in the specified namespace
            var indentedClasses = CodeFormatter.IndentCode(
                string.Join(CodeFormatter.DefaultNewLine, dtoClasses),
                CodeFormatter.IndentSize
            );
            return $$"""
                namespace {{namespaceName}}
                {
                {{indentedClasses}}
                }
                """;
        }
    }

    // Generate DTO part with DTOs grouped by their namespace.
    public static string BuildDtoCodeSnippetsGroupedByNamespace(
        List<GenerateDtoClassInfo> dtoClassInfos,
        LinqraftConfiguration configuration
    )
    {
        // Group DTOs by namespace
        var dtosByNamespace = dtoClassInfos
            .GroupBy(c => c.Namespace)
            .OrderBy(g => g.Key) // Sort for consistent output
            .ToList();

        var result = new List<string>();

        foreach (var group in dtosByNamespace)
        {
            var namespaceName = group.Key;
            var dtoClasses = group.Select(c => c.BuildCode(configuration)).ToList();

            if (string.IsNullOrEmpty(namespaceName))
            {
                // Generate DTOs in global namespace (no namespace wrapper)
                result.Add(string.Join(CodeFormatter.DefaultNewLine, dtoClasses));
            }
            else
            {
                // Generate DTOs in the specified namespace
                var indentedClasses = CodeFormatter.IndentCode(
                    string.Join(CodeFormatter.DefaultNewLine, dtoClasses),
                    CodeFormatter.IndentSize
                );
                result.Add(
                    $$"""
                    namespace {{namespaceName}}
                    {
                    {{indentedClasses}}
                    }
                    """
                );
            }
        }

        return string.Join(CodeFormatter.DefaultNewLine, result);
    }

    // Attributes for DTO classes
    public static string BuildDtoCodeAttributes()
    {
        return """
            [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
            [global::Linqraft.LinqraftAutoGeneratedDtoAttribute]
            """;
    }

    [StringSyntax("csharp")]
    private const string EmbeddedAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        namespace Microsoft.CodeAnalysis
        {
            internal sealed partial class EmbeddedAttribute : global::System.Attribute
            {
            }
        }
        """;

    [StringSyntax("csharp")]
    public const string InterceptsLocationAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace System.Runtime.CompilerServices
        {
            [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            [EmbeddedAttribute]
            internal sealed class InterceptsLocationAttribute : Attribute
            {
                public InterceptsLocationAttribute(int version, string data)
                {
                    Version = version;
                    Data = data;
                }

                public int Version { get; }
                public string Data { get; }
            }
        }
        """;

    /// <summary>
    /// Attribute to mark auto-generated DTO classes.
    /// This attribute is used by Linqraft analyzers to detect explicit usage of auto-generated DTOs.
    /// </summary>
    [StringSyntax("csharp")]
    public const string LinqraftAutoGeneratedDtoAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace Linqraft
        {
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            [EmbeddedAttribute]
            internal sealed class LinqraftAutoGeneratedDtoAttribute : Attribute
            {
            }
        }
        """;

    /// <summary>
    /// Attribute to mark methods for Linqraft mapping generation.
    /// This attribute is used to generate extension methods instead of using interceptors,
    /// which is useful for EFCore query (pre)compilation and other scenarios where interceptors
    /// are not supported.
    /// </summary>
    [StringSyntax("csharp")]
    public const string LinqraftMappingGenerateAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;
        using Microsoft.CodeAnalysis;

        namespace Linqraft
        {
            /// <summary>
            /// Marks a method for Linqraft mapping generation. The method must be in a static partial class
            /// and contain a SelectExpr call. Linqraft will generate an extension method with the specified
            /// name that contains the compiled Select expression.
            /// This is useful for EFCore query (pre)compilation support where interceptors cannot be used.
            /// </summary>
            /// <example>
            /// <code>
            /// public static partial class SampleClassQueries
            /// {
            ///     [LinqraftMappingGenerate("ProjectToDto")]
            ///     internal static IQueryable&lt;SampleDto&gt; DummyQuery(this IQueryable&lt;SampleClass&gt; source) =&gt; source
            ///         .SelectExpr&lt;SampleClass, SampleDto&gt;(x => new { x.Id, x.Name });
            /// }
            /// </code>
            /// </example>
            [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            [EmbeddedAttribute]
            internal sealed class LinqraftMappingGenerateAttribute : Attribute
            {
                /// <summary>
                /// Initializes a new instance of the LinqraftMappingGenerateAttribute class.
                /// </summary>
                /// <param name="methodName">The name of the extension method to generate.</param>
                public LinqraftMappingGenerateAttribute(string methodName)
                {
                    MethodName = methodName;
                }

                /// <summary>
                /// Gets the name of the extension method to generate.
                /// </summary>
                public string MethodName { get; }
            }
        }
        """;

    [StringSyntax("csharp")]
    public const string SelectExprExtensions = $$""""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        {{GenerateHeaderUsingPart}}

        /// <summary>
        /// Dummy expression methods for Linqraft to compile correctly.
        /// </summary>
        internal static class SelectExprExtensions
        {
            /// <summary>
            /// Create select expression method, usable nullable operators, and generate instance DTOs.
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, usable nullable operators, and generate instance DTOs.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector, object capture)
                where TIn : class => throw InvalidException;

            private static Exception InvalidException => new System.InvalidOperationException(SelectExprErrorMessage); 

            private const string SelectExprErrorMessage = """
        {{SelectExprErrorMessage}}
        """;
        }
        """";

    private const string SelectExprErrorMessage = """
        This is a dummy method for Linqraft source generator and should not be called directly.
        If you see this message, it is likely due to a bug. Please contact us via the Linqraft Issue page.
        https://github.com/arika0093/Linqraft/issues
        """;

    private static string GenerateCommentHeaderPart()
    {
#if DEBUG
        var now = DateTime.Now;
        var buildDate = BuildDateTimeAttribute.GetBuildDateTimeUtc()?.ToLocalTime();
        var buildDateString = buildDate?.ToString("yyyy-MM-dd HH:mm:ss") ?? "Unknown";
        return $"""
            // <auto-generated>
            // This file is auto-generated by Linqraft.
            //   Linqraft Version  : {ThisAssembly.AssemblyInformationalVersion}
            //   Linqraft Build at : {buildDateString}
            //   Code Generated at : {now:yyyy-MM-dd HH:mm:ss}
            // </auto-generated>
            """;
#else
        return CommentHeaderPartOnProd;
#endif
    }

    private const string CommentHeaderPartOnProd = $"""
        // <auto-generated>
        // This file is auto-generated by Linqraft (ver. {ThisAssembly.AssemblyVersion})
        // </auto-generated>
        """;

    private const string GenerateHeaderFlagsPart = """
        #nullable enable
        #pragma warning disable IDE0060
        #pragma warning disable CS8601
        #pragma warning disable CS8602
        #pragma warning disable CS8603
        #pragma warning disable CS8604
        #pragma warning disable CS8618
        """;

    private const string GenerateHeaderUsingPart = """
        using System;
        using System.Linq;
        using System.Linq.Expressions;
        using System.Collections.Generic;
        using System.Collections.Immutable;
        """;

    // OverloadPriorityAttribute is usable C# 13 or later.
    // but we cannot detect C# language version in source generator,
    // so we use .NET version as a proxy here.
    private const string OverloadPriorityAttribute = """
        #if NET9_0_OR_GREATER
            [System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute(-1)]
        #endif
        """;
}
