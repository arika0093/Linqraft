using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Linqraft.Core.Formatting;
using Microsoft.CodeAnalysis;

namespace Linqraft.Core;

public static class GenerateSourceCodeSnippets
{
    // Export all source codes
    public static void ExportAllConstantSnippets(
        IncrementalGeneratorPostInitializationContext context
    )
    {
        context.AddSource("InterceptsLocationAttribute.g.cs", InterceptsLocationAttribute);
        context.AddSource("SelectExprExtensions.g.cs", SelectExprExtensions);
        context.AddSource(
            "LinqraftAutoGeneratedDtoAttribute.g.cs",
            LinqraftAutoGeneratedDtoAttribute
        );
    }

    // Generate total code with DTOs that may have different namespaces.
    public static string BuildCodeSnippetAll(
        List<string> expressions,
        List<GenerateDtoClassInfo> dtoClassInfos,
        LinqraftConfiguration configuration
    )
    {
        var exprPart = BuildExprCodeSnippets(expressions);
        var dtoPart = BuildDtoCodeSnippetsGroupedByNamespace(dtoClassInfos, configuration);
        return $$"""
            {{GenerateCommentHeaderPart()}}
            {{GenerateHeaderFlagsPart}}
            {{exprPart}}
            {{dtoPart}}
            """;
    }

    // Generate expression part
    public static string BuildExprCodeSnippets(List<string> expressions)
    {
        var indentedExpr = CodeFormatter.IndentCode(
            string.Join(CodeFormatter.DefaultNewLine, expressions),
            CodeFormatter.IndentSize * 2
        );
        return $$"""
            {{GenerateHeaderUsingPart}}
            namespace Linqraft
            {
                file static partial class GeneratedExpression
                {
            {{indentedExpr}}
                }
            }
            """;
    }

    // Generate DTO part
    public static string BuildDtoCodeSnippets(List<string> dtoClasses, string namespaceName)
    {
        if (string.IsNullOrEmpty(namespaceName))
        {
            // Generate DTOs in global namespace (no namespace wrapper)
            return string.Join(CodeFormatter.DefaultNewLine, dtoClasses);
        }
        else
        {
            // Generate DTOs in the specified namespace
            var indentedClasses = CodeFormatter.IndentCode(
                string.Join(CodeFormatter.DefaultNewLine, dtoClasses),
                CodeFormatter.IndentSize
            );
            return $$"""
                namespace {{namespaceName}}
                {
                {{indentedClasses}}
                }
                """;
        }
    }

    // Generate DTO part with DTOs grouped by their namespace.
    public static string BuildDtoCodeSnippetsGroupedByNamespace(
        List<GenerateDtoClassInfo> dtoClassInfos,
        LinqraftConfiguration configuration
    )
    {
        // Group DTOs by namespace
        var dtosByNamespace = dtoClassInfos
            .GroupBy(c => c.Namespace)
            .OrderBy(g => g.Key) // Sort for consistent output
            .ToList();

        var result = new List<string>();

        foreach (var group in dtosByNamespace)
        {
            var namespaceName = group.Key;
            var dtoClasses = group.Select(c => c.BuildCode(configuration)).ToList();

            if (string.IsNullOrEmpty(namespaceName))
            {
                // Generate DTOs in global namespace (no namespace wrapper)
                result.Add(string.Join(CodeFormatter.DefaultNewLine, dtoClasses));
            }
            else
            {
                // Generate DTOs in the specified namespace
                var indentedClasses = CodeFormatter.IndentCode(
                    string.Join(CodeFormatter.DefaultNewLine, dtoClasses),
                    CodeFormatter.IndentSize
                );
                result.Add(
                    $$"""
                    namespace {{namespaceName}}
                    {
                    {{indentedClasses}}
                    }
                    """
                );
            }
        }

        return string.Join(CodeFormatter.DefaultNewLine, result);
    }

    // Attributes for DTO classes
    public static string BuildDtoCodeAttributes()
    {
        return """
            [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
            [global::Linqraft.LinqraftAutoGeneratedDtoAttribute]
            """;
    }

    [StringSyntax("csharp")]
    public const string InterceptsLocationAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;

        namespace System.Runtime.CompilerServices
        {
            [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            internal sealed class InterceptsLocationAttribute : Attribute
            {
                public InterceptsLocationAttribute(int version, string data)
                {
                    Version = version;
                    Data = data;
                }

                public int Version { get; }
                public string Data { get; }
            }
        }
        """;

    /// <summary>
    /// Attribute to mark auto-generated DTO classes.
    /// This attribute is used by Linqraft analyzers to detect explicit usage of auto-generated DTOs.
    /// </summary>
    [StringSyntax("csharp")]
    public const string LinqraftAutoGeneratedDtoAttribute = $$"""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        using System;
        using System.ComponentModel;

        namespace Linqraft
        {
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
            [EditorBrowsable(EditorBrowsableState.Never)]
            internal sealed class LinqraftAutoGeneratedDtoAttribute : Attribute
            {
            }
        }
        """;

    [StringSyntax("csharp")]
    public const string SelectExprExtensions = $$""""
        {{CommentHeaderPartOnProd}}
        #nullable enable
        {{GenerateHeaderUsingPart}}

        namespace Linqraft
        {
            /// <summary>
            /// Configuration options for Linqraft source generator (per-invocation)
            /// </summary>
            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            internal sealed class LinqraftConfiguration
            {
                /// <summary>
                /// The namespace where global namespace DTOs should exist.
                /// Default is null (use global configuration)
                /// </summary>
                public string? GlobalNamespace { get; init; }

                /// <summary>
                /// Whether to generate records instead of classes.
                /// Default is null (use global configuration)
                /// </summary>
                public bool? RecordGenerate { get; init; }

                /// <summary>
                /// The property accessor pattern to use for generated DTOs.
                /// Default is null (use global configuration)
                /// </summary>
                public PropertyAccessor? PropertyAccessor { get; init; }

                /// <summary>
                /// Whether to use the 'required' keyword on generated DTO properties.
                /// Default is null (use global configuration)
                /// </summary>
                public bool? HasRequired { get; init; }

                /// <summary>
                /// The comment output mode for generated DTO classes and properties.
                /// Default is null (use global configuration)
                /// </summary>
                public CommentOutputMode? CommentOutput { get; init; }

                /// <summary>
                /// Whether to remove nullable annotation from collection types with Select/SelectMany
                /// and use empty collection fallback instead of null.
                /// Default is null (use global configuration)
                /// </summary>
                public bool? ArrayNullabilityRemoval { get; init; }

                /// <summary>
                /// Whether to generate nested DTOs in a hash-named namespace instead of using hash suffix on the class name.
                /// Default is null (use global configuration)
                /// </summary>
                public bool? NestedDtoUseHashNamespace { get; init; }
            }

            /// <summary>
            /// Property accessor patterns for generated DTOs
            /// </summary>
            internal enum PropertyAccessor
            {
                /// <summary>
                /// Use default based on record/class type
                /// </summary>
                Default = 0,

                /// <summary>
                /// get; set; - mutable properties
                /// </summary>
                GetAndSet = 1,

                /// <summary>
                /// get; init; - init-only properties
                /// </summary>
                GetAndInit = 2,

                /// <summary>
                /// get; internal set; - read-only outside assembly
                /// </summary>
                GetAndInternalSet = 3,
            }

            /// <summary>
            /// Comment output modes for generated DTOs
            /// </summary>
            internal enum CommentOutputMode
            {
                /// <summary>
                /// Include all comments: XML documentation, source references, and attribute information
                /// </summary>
                All = 0,

                /// <summary>
                /// Include only comments from the source class/property (XML documentation, Comment attribute, Display attribute)
                /// Does not include source references (From:) or attribute information
                /// </summary>
                SummaryOnly = 1,

                /// <summary>
                /// Do not include any comments in generated DTOs
                /// </summary>
                None = 2,
            }
        }

        /// <summary>
        /// Dummy expression methods for Linqraft to compile correctly.
        /// </summary>
        internal static class SelectExprExtensions
        {
            /// <summary>
            /// Create select expression method, usable nullable operators, and generate instance DTOs.
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, usable nullable operators, and generate instance DTOs.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector, object capture)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with per-invocation configuration, usable nullable operators, and generate instance DTOs.
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with per-invocation configuration, usable nullable operators, and generate instance DTOs.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with per-invocation configuration, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with per-invocation configuration, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables and per-invocation configuration, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, TResult> selector, object capture, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables and per-invocation configuration, usable nullable operators, and generate instance DTOs.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IQueryable<TResult> SelectExpr<TIn, TResult>(this IQueryable<TIn> query, Func<TIn, object> selector, object capture, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables and per-invocation configuration, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, TResult> selector, object capture, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            /// <summary>
            /// Create select expression method with captured local variables and per-invocation configuration, with generate instance DTOs.
            /// Works with IEnumerable where nullable operators are supported natively.
            /// Pass local variables as an anonymous object: new { var1, var2, ... }
            /// </summary>
        {{OverloadPriorityAttribute}}
            public static IEnumerable<TResult> SelectExpr<TIn, TResult>(this IEnumerable<TIn> query, Func<TIn, object> selector, object capture, Linqraft.LinqraftConfiguration config)
                where TIn : class => throw InvalidException;

            private static Exception InvalidException => new System.InvalidOperationException(SelectExprErrorMessage); 

            private const string SelectExprErrorMessage = """
        {{SelectExprErrorMessage}}
        """;
        }
        """";

    private const string SelectExprErrorMessage = """
        This is a dummy method for Linqraft source generator and should not be called directly.
        If you see this message, it is likely due to a bug. Please contact us via the Linqraft Issue page.
        https://github.com/arika0093/Linqraft/issues
        """;

    private static string GenerateCommentHeaderPart()
    {
#if DEBUG
        var now = DateTime.Now;
        var buildDate = BuildDateTimeAttribute.GetBuildDateTimeUtc()?.ToLocalTime();
        var buildDateString = buildDate?.ToString("yyyy-MM-dd HH:mm:ss") ?? "Unknown";
        return $"""
            // <auto-generated>
            // This file is auto-generated by Linqraft.
            //   Linqraft Version  : {ThisAssembly.AssemblyInformationalVersion}
            //   Linqraft Build at : {buildDateString}
            //   Code Generated at : {now:yyyy-MM-dd HH:mm:ss}
            // </auto-generated>
            """;
#else
        return CommentHeaderPartOnProd;
#endif
    }

    private const string CommentHeaderPartOnProd = $"""
        // <auto-generated>
        // This file is auto-generated by Linqraft (ver. {ThisAssembly.AssemblyVersion})
        // </auto-generated>
        """;

    private const string GenerateHeaderFlagsPart = """
        #nullable enable
        #pragma warning disable IDE0060
        #pragma warning disable CS8601
        #pragma warning disable CS8602
        #pragma warning disable CS8603
        #pragma warning disable CS8604
        #pragma warning disable CS8618
        """;

    private const string GenerateHeaderUsingPart = """
        using System;
        using System.Linq;
        using System.Collections.Generic;
        using System.Collections.Immutable;
        """;

    // OverloadPriorityAttribute is usable C# 13 or later.
    // but we cannot detect C# language version in source generator,
    // so we use .NET version as a proxy here.
    private const string OverloadPriorityAttribute = """
        #if NET9_0_OR_GREATER
            [System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute(-1)]
        #endif
        """;
}
