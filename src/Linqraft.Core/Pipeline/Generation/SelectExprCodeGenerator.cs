using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Linqraft.Core.Formatting;
using Linqraft.Core.Pipeline.Analysis;
using Linqraft.Core.RoslynHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Linqraft.Core.Pipeline.Generation;

/// <summary>
/// Generates code for SelectExpr interceptor methods using the pipeline architecture.
/// This handles the transformation of SelectExpr calls to Select calls with proper DTO types.
/// </summary>
internal class SelectExprCodeGenerator
{
    private readonly CodeGenerationPipeline _pipeline;
    private readonly LinqraftConfiguration _configuration;

    /// <summary>
    /// Creates a new SelectExpr code generator.
    /// </summary>
    public SelectExprCodeGenerator(CodeGenerationPipeline pipeline)
    {
        _pipeline = pipeline;
        _configuration = pipeline.Configuration;
    }

    /// <summary>
    /// Generates the interceptor method for a SelectExpr call.
    /// </summary>
    /// <param name="result">The processing result from the pipeline processor</param>
    /// <param name="location">The interceptable location</param>
    /// <param name="isEnumerable">Whether the source is IEnumerable (not IQueryable)</param>
    /// <param name="sourceTypeFullName">The fully qualified source type name</param>
    /// <returns>The generated interceptor method code</returns>
    public string GenerateInterceptorMethod(
        SelectExprProcessingResult result,
        InterceptableLocation location,
        bool isEnumerable,
        string sourceTypeFullName)
    {
        if (!result.IsValid || result.DtoStructure is null)
            return "";

        var dtoClassName = result.RootDtoClassName;
        var structure = result.DtoStructure;
        var lambdaParamName = result.LambdaParameterName;
        var returnTypePrefix = isEnumerable ? "IEnumerable" : "IQueryable";

        var sb = new StringBuilder();

        // Generate method header with documentation and interceptor attribute
        var typeString = result.IsExplicitDto ? "explicit" : (result.IsAnonymous ? "anonymous" : "named");
        var displayLocationRaw = location.GetDisplayLocation();
        var locationFileOnly = displayLocationRaw.Split(new[] { '/', '\\' }).Last();

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// generated select expression method {dtoClassName} ({typeString}) <br/>");
        sb.AppendLine($"/// at {locationFileOnly}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine(location.GetInterceptsLocationAttributeSyntax());

        // Generate method signature
        sb.AppendLine($"internal static {returnTypePrefix}<{dtoClassName}> SelectExpr_{GenerateMethodSuffix(location)}(");
        sb.AppendLine($"    this {returnTypePrefix}<{sourceTypeFullName}> source,");
        sb.AppendLine($"    Func<{sourceTypeFullName}, object> _)");
        sb.AppendLine($"{{");

        // Generate Select body
        sb.AppendLine($"    return source.Select({lambdaParamName} => new {dtoClassName}");
        sb.AppendLine($"    {{");

        foreach (var prop in structure.Properties)
        {
            var assignment = GeneratePropertyAssignment(prop, 8, lambdaParamName);
            sb.AppendLine($"        {prop.Name} = {assignment},");
        }

        sb.AppendLine($"    }});");
        sb.AppendLine($"}}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates an extension method for mapping (no interceptor).
    /// </summary>
    /// <param name="result">The processing result from the pipeline processor</param>
    /// <param name="methodName">The name of the extension method to generate</param>
    /// <param name="sourceTypeFullName">The fully qualified source type name</param>
    /// <param name="isEnumerable">Whether the source is IEnumerable (not IQueryable)</param>
    /// <returns>The generated extension method code</returns>
    public string GenerateMappingMethod(
        SelectExprProcessingResult result,
        string methodName,
        string sourceTypeFullName,
        bool isEnumerable)
    {
        if (!result.IsValid || result.DtoStructure is null)
            return "";

        var dtoClassName = result.RootDtoClassName;
        var structure = result.DtoStructure;
        var lambdaParamName = result.LambdaParameterName;
        var returnTypePrefix = isEnumerable ? "IEnumerable" : "IQueryable";

        var sb = new StringBuilder();

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Extension method generated by LinqraftMappingGenerate attribute");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal static {returnTypePrefix}<{dtoClassName}> {methodName}(");
        sb.AppendLine($"    this {returnTypePrefix}<{sourceTypeFullName}> source)");
        sb.AppendLine($"{{");
        sb.AppendLine($"    return source.Select({lambdaParamName} => new {dtoClassName}");
        sb.AppendLine($"    {{");

        foreach (var prop in structure.Properties)
        {
            var assignment = GeneratePropertyAssignment(prop, 8, lambdaParamName);
            sb.AppendLine($"        {prop.Name} = {assignment},");
        }

        sb.AppendLine($"    }});");
        sb.AppendLine($"}}");

        return sb.ToString();
    }

    /// <summary>
    /// Generates property assignment code for a single property.
    /// </summary>
    private string GeneratePropertyAssignment(DtoProperty property, int indents, string lambdaParamName)
    {
        return _pipeline.PropertyAssignmentGenerator.GeneratePropertyAssignment(
            property, indents, lambdaParamName, "");
    }

    /// <summary>
    /// Generates a unique method suffix from the location.
    /// </summary>
    private static string GenerateMethodSuffix(InterceptableLocation location)
    {
        return HashUtility.GenerateSha256Hash(location.Data, 8);
    }
}

/// <summary>
/// Builds static field declarations for capture expressions.
/// </summary>
internal class StaticFieldGenerator
{
    private readonly SemanticModel _semanticModel;

    /// <summary>
    /// Creates a new static field generator.
    /// </summary>
    public StaticFieldGenerator(SemanticModel semanticModel)
    {
        _semanticModel = semanticModel;
    }

    /// <summary>
    /// Generates static field declarations for captured variables.
    /// </summary>
    public string? GenerateStaticFields(
        ITypeSymbol? captureArgumentType,
        string captureExpression)
    {
        if (captureArgumentType is null)
            return null;

        // This is a placeholder - the actual implementation would analyze
        // the capture type and generate appropriate static field declarations
        return null;
    }
}
