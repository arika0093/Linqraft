using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Linqraft.Core.Formatting;
using Microsoft.CodeAnalysis;

namespace Linqraft.Core.Pipeline.Generation;

/// <summary>
/// Generates mapping extension methods from SelectExprInfo.
/// This is part of the Generation phase of the pipeline.
/// </summary>
internal class MappingMethodGenerator
{
    private readonly SemanticModel _semanticModel;
    private readonly LinqraftConfiguration _configuration;

    /// <summary>
    /// Creates a new mapping method generator.
    /// </summary>
    public MappingMethodGenerator(SemanticModel semanticModel, LinqraftConfiguration configuration)
    {
        _semanticModel = semanticModel;
        _configuration = configuration;
    }

    /// <summary>
    /// Generates a mapping extension method.
    /// </summary>
    public string GenerateMappingMethod(
        string methodName,
        string dtoClassName,
        string sourceTypeFullName,
        string returnTypePrefix,
        string lambdaParameterName,
        List<PropertyAssignment> propertyAssignments)
    {
        var sb = new StringBuilder();

        // Generate XML documentation
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension method generated by LinqraftMappingGenerate attribute");
        sb.AppendLine("/// </summary>");

        // Generate method signature as an extension method
        sb.AppendLine($"internal static {returnTypePrefix}<{dtoClassName}> {methodName}(");
        sb.AppendLine($"    this {returnTypePrefix}<{sourceTypeFullName}> source)");
        sb.AppendLine("{");
        sb.AppendLine($"    return source.Select({lambdaParameterName} => new {dtoClassName}");
        sb.AppendLine("    {");

        // Generate property assignments
        foreach (var assignment in propertyAssignments)
        {
            sb.AppendLine($"        {assignment.PropertyName} = {assignment.Expression},");
        }

        sb.AppendLine("    });");
        sb.AppendLine("}");
        sb.AppendLine();

        return sb.ToString();
    }

    /// <summary>
    /// Builds the mapping class wrapper code.
    /// </summary>
    public string BuildMappingClassCode(
        INamedTypeSymbol containingClass,
        List<string> methods,
        string? customClassName = null)
    {
        if (customClassName != null)
        {
            return GenerateSourceCodeSnippets.BuildMappingClassCode(containingClass, methods, customClassName);
        }
        return GenerateSourceCodeSnippets.BuildMappingClassCode(containingClass, methods);
    }
}
