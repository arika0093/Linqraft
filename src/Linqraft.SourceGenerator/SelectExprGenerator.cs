using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Linqraft;

/// <summary>
/// Generator for SelectExpr method
/// </summary>
[Generator]
public partial class SelectExprGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initialize the generator
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate InterceptsLocationAttribute for the consuming project
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                "InterceptsLocationAttribute.g.cs",
                """
                // <auto-generated />
                #nullable enable
                namespace System.Runtime.CompilerServices
                {
                    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                    internal sealed class InterceptsLocationAttribute : Attribute
                    {
                        public InterceptsLocationAttribute(int version, string data)
                        {
                            Version = version;
                            Data = data;
                        }

                        public int Version { get; }
                        public string Data { get; }
                    }
                }
                """
            );
        });

        // Provider to detect SelectExpr method invocations
        var invocations = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => IsSelectExprInvocation(node),
                transform: static (ctx, _) => GetSelectExprInfo(ctx)
            )
            .Where(static info => info is not null)
            .Collect();

        // Code generation
        context.RegisterSourceOutput(
            invocations,
            (spc, infos) =>
            {
                var infoWithoutNulls = infos.Where(info => info is not null).Select(info => info!);

                // record locations by SelectExprInfo Id
                var exprGroups = infoWithoutNulls
                    .GroupBy(info => info.GetNamespaceString())
                    .Select(g =>
                    {
                        var exprs = g.Select(info =>
                        {
                            var location = info.SemanticModel.GetInterceptableLocation(
                                info.Invocation
                            )!;
                            return new SelectExprLocations { Info = info, Location = location };
                        });
                        return new SelectExprGroups
                        {
                            TargetNamespace = g.Key,
                            Exprs = exprs.ToList(),
                        };
                    })
                    .ToList();

                // Generate code for explicit DTO infos (one method per group)
                foreach (var exprGroup in exprGroups)
                {
                    exprGroup.GenerateCode(spc);
                }

                // Generate navigation helper file for easy discovery
                if (exprGroups.Count > 0)
                {
                    GenerateNavigationHelper(spc, exprGroups);
                }
            }
        );
    }

    private static void GenerateNavigationHelper(
        SourceProductionContext context,
        List<SelectExprGroups> exprGroups
    )
    {
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("/*");
        sb.AppendLine(" * ========================================");
        sb.AppendLine(" * SelectExpr Navigation Helper");
        sb.AppendLine(" * ========================================");
        sb.AppendLine(" * ");
        sb.AppendLine(" * This file provides an index of all SelectExpr usages in your code");
        sb.AppendLine(" * and their corresponding generated implementations.");
        sb.AppendLine(" * ");
        sb.AppendLine(" * To view the generated code for a specific SelectExpr call:");
        sb.AppendLine(" * 1. Find the call location in the list below");
        sb.AppendLine(" * 2. Note the generated method name");
        sb.AppendLine(" * 3. Open the corresponding GeneratedExpression_*.g.cs file");
        sb.AppendLine(" * 4. Search for the method name");
        sb.AppendLine(" * ");
        sb.AppendLine(" * Alternatively:");
        sb.AppendLine(" * - Use \"Go to Implementation\" (Ctrl+F12) on the SelectExpr call");
        sb.AppendLine(" * - Check the .generated folder if EmitCompilerGeneratedFiles is enabled");
        sb.AppendLine(" * ");
        sb.AppendLine(" * ========================================");
        sb.AppendLine(" * ");

        int totalCount = 0;
        foreach (var group in exprGroups)
        {
            sb.AppendLine($" * Namespace: {group.TargetNamespace}");
            sb.AppendLine($" * Generated file: GeneratedExpression_{group.GetUniqueId()}.g.cs");
            sb.AppendLine(" * ");

            foreach (var expr in group.Exprs)
            {
                var location = expr.Location.GetDisplayLocation();
                var info = expr.Info;

                // Get method name by parsing the generated code
                var generatedCode = info.GenerateSelectExprCodes(expr.Location);
                if (generatedCode.Count > 0)
                {
                    var methodCode = generatedCode[0];
                    // Extract method name from the generated code
                    var methodNameMatch = System.Text.RegularExpressions.Regex.Match(
                        methodCode,
                        @"SelectExpr_[A-F0-9_]+"
                    );
                    var methodName = methodNameMatch.Success
                        ? methodNameMatch.Value
                        : "SelectExpr_<unknown>";

                    sb.AppendLine($" * [{++totalCount}] {location}");
                    sb.AppendLine($" *     Generated method: {methodName}");
                    sb.AppendLine(" * ");
                }
            }

            sb.AppendLine(" * ----------------------------------------");
            sb.AppendLine(" * ");
        }

        sb.AppendLine($" * Total SelectExpr usages: {totalCount}");
        sb.AppendLine(" * ");
        sb.AppendLine(" * ========================================");
        sb.AppendLine(" */");

        context.AddSource("SelectExprNavigationHelper.g.cs", sb.ToString());
    }

    private static bool IsSelectExprInvocation(SyntaxNode node)
    {
        // Detect InvocationExpression with method name "SelectExpr"
        if (node is not InvocationExpressionSyntax invocation)
            return false;

        var expression = invocation.Expression;

        // MemberAccessExpression (e.g., query.SelectExpr)
        if (expression is MemberAccessExpressionSyntax memberAccess)
        {
            return memberAccess.Name.Identifier.Text == "SelectExpr";
        }

        return false;
    }

    private static SelectExprInfo? GetSelectExprInfo(GeneratorSyntaxContext context)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        // Get lambda expression from arguments
        if (invocation.ArgumentList.Arguments.Count == 0)
            return null;

        var lambdaArg = invocation.ArgumentList.Arguments[0].Expression;
        if (lambdaArg is not LambdaExpressionSyntax lambda)
            return null;

        // Extract lambda parameter name
        var lambdaParamName = GetLambdaParameterName(lambda);

        // Check if this is a generic invocation with explicit type arguments
        // SelectExpr<TIn, TResult> form
        if (
            invocation.Expression is MemberAccessExpressionSyntax memberAccess
            && memberAccess.Name is GenericNameSyntax genericName
            && genericName.TypeArgumentList.Arguments.Count == 2
        )
        {
            // This is the new SelectExpr<TIn, TResult> form
            if (lambda.Body is AnonymousObjectCreationExpressionSyntax anon)
            {
                return GetExplicitDtoSelectExprInfo(context, anon, genericName, lambdaParamName);
            }
        }

        // Check if lambda body is an object initializer
        var body = lambda.Body;
        switch (body)
        {
            case AnonymousObjectCreationExpressionSyntax anon:
                return GetAnonymousSelectExprInfo(context, anon, lambdaParamName);
            case ObjectCreationExpressionSyntax objCreation:
                return GetNamedSelectExprInfo(context, objCreation, lambdaParamName);
            default:
                return null;
        }
    }

    private static string GetLambdaParameterName(LambdaExpressionSyntax lambda)
    {
        return lambda switch
        {
            SimpleLambdaExpressionSyntax simple => simple.Parameter.Identifier.Text,
            ParenthesizedLambdaExpressionSyntax paren
                when paren.ParameterList.Parameters.Count > 0 => paren
                .ParameterList
                .Parameters[0]
                .Identifier
                .Text,
            _ => "s", // fallback to default
        };
    }

    private static SelectExprInfoAnonymous? GetAnonymousSelectExprInfo(
        GeneratorSyntaxContext context,
        AnonymousObjectCreationExpressionSyntax anonymousObj,
        string lambdaParameterName
    )
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get target type from MemberAccessExpression
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        // Get type information
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        // Get T from IQueryable<T>
        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        // Get the namespace of the calling code
        var namespaceDecl = invocation
            .Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();
        var callerNamespace = namespaceDecl?.Name.ToString() ?? "";

        return new SelectExprInfoAnonymous
        {
            SourceType = sourceType,
            AnonymousObject = anonymousObj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            LambdaParameterName = lambdaParameterName,
            CallerNamespace = callerNamespace,
        };
    }

    private static SelectExprInfoNamed? GetNamedSelectExprInfo(
        GeneratorSyntaxContext context,
        ObjectCreationExpressionSyntax obj,
        string lambdaParameterName
    )
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get target type from MemberAccessExpression
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        // Get type information
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        // Get T from IQueryable<T>
        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        // Get the namespace of the calling code
        var namespaceDecl = invocation
            .Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();
        var callerNamespace = namespaceDecl?.Name.ToString() ?? "";

        return new SelectExprInfoNamed
        {
            SourceType = sourceType,
            ObjectCreation = obj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            LambdaParameterName = lambdaParameterName,
            CallerNamespace = callerNamespace,
        };
    }

    private static SelectExprInfoExplicitDto? GetExplicitDtoSelectExprInfo(
        GeneratorSyntaxContext context,
        AnonymousObjectCreationExpressionSyntax anonymousObj,
        GenericNameSyntax genericName,
        string lambdaParameterName
    )
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get target type from MemberAccessExpression
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        // Get type information
        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        // Get TIn from IQueryable<TIn>
        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        // Get TResult (second type parameter) - this is the explicit DTO name
        var typeArguments = genericName.TypeArgumentList.Arguments;
        if (typeArguments.Count != 2)
            return null;

        var tResultType = semanticModel.GetTypeInfo(typeArguments[1]).Type;
        if (tResultType is null)
            return null;

        var explicitDtoName = tResultType.Name;

        // Extract parent class names if the DTO type is nested
        var parentClasses = new List<string>();
        var currentContaining = tResultType.ContainingType;
        while (currentContaining is not null)
        {
            parentClasses.Insert(0, currentContaining.Name);
            currentContaining = currentContaining.ContainingType;
        }

        // Get the namespace of the calling code
        var invocationSyntaxTree = invocation.SyntaxTree;
        var root = invocationSyntaxTree.GetRoot();
        var namespaceDecl = invocation
            .Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();
        var targetNamespace = namespaceDecl?.Name.ToString() ?? "";

        return new SelectExprInfoExplicitDto
        {
            SourceType = sourceType,
            AnonymousObject = anonymousObj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            ExplicitDtoName = explicitDtoName,
            TargetNamespace = targetNamespace,
            LambdaParameterName = lambdaParameterName,
            CallerNamespace = targetNamespace,
            ParentClasses = parentClasses,
            TResultType = tResultType,
        };
    }
}
