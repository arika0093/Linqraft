using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EFCore.ExprGenerator;

/// <summary>
/// Record for explicit DTO name Select expression information (SelectExpr&lt;TIn, TResult&gt; form)
/// </summary>
internal record SelectExprInfoExplicitDto : SelectExprInfo
{
    public required AnonymousObjectCreationExpressionSyntax AnonymousObject { get; init; }
    public required string ExplicitDtoName { get; init; }
    public required string TargetNamespace { get; init; }

    // Store multiple locations that should be intercepted by this same method
    public List<InterceptableLocation> Locations { get; init; } = [];

    public override DtoStructure GenerateDtoStructure()
    {
        return DtoStructure.AnalyzeAnonymousType(AnonymousObject, SemanticModel, SourceType)!;
    }

    public override string GenerateDtoClasses(DtoStructure structure, List<string> dtoClasses)
    {
        var accessibility = GetAccessibilityString(SourceType);

        var sb = new StringBuilder();
        sb.AppendLine($"{accessibility} class {ExplicitDtoName}");
        sb.AppendLine("{");

        foreach (var prop in structure.Properties)
        {
            var propertyType = prop.TypeName;

            // For nested structures, recursively generate DTOs (add first)
            if (prop.NestedStructure is not null)
            {
                // Extract the base type (e.g., IEnumerable from IEnumerable<T>)
                var baseType = propertyType;
                if (propertyType.Contains("<"))
                {
                    baseType = propertyType[..propertyType.IndexOf("<")];
                }

                var nestedDtoName = GenerateDtoClasses(prop.NestedStructure, dtoClasses);
                propertyType = $"{baseType}<{nestedDtoName}>";
            }
            sb.AppendLine($"    public required {propertyType} {prop.Name} {{ get; set; }}");
        }

        sb.AppendLine("}");

        // Add current DTO (nested DTOs are already added by recursive calls)
        dtoClasses.Add(sb.ToString());
        return ExplicitDtoName;
    }

    protected override string GenerateSelectExprMethod(
        string dtoName,
        DtoStructure structure,
        InterceptableLocation location
    )
    {
        // This method is not used directly; we override GenerateCode instead
        throw new NotImplementedException(
            "Use GenerateCode override for SelectExprInfoExplicitDto"
        );
    }

    public override string GetClassName(DtoStructure structure) => ExplicitDtoName;

    protected override string BuildSourceCode(
        string mainDtoName,
        List<string> dtoClasses,
        string selectExprMethod
    )
    {
        var accessibility = GetAccessibilityString(SourceType);
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable IDE0060");
        sb.AppendLine("#pragma warning disable CS8601");
        sb.AppendLine();
        sb.AppendLine(GetUsingNamespaceString());
        sb.AppendLine();

        // EFCore.ExprGenerator namespace for the SelectExpr method
        var indentedMethod = string.Join("\n", selectExprMethod.Split('\n'));
        sb.AppendLine("namespace EFCore.ExprGenerator");
        sb.AppendLine("{");
        sb.AppendLine(indentedMethod);
        sb.AppendLine("}");
        sb.AppendLine();

        // Add DTO classes in the target namespace
        sb.AppendLine($"namespace {TargetNamespace}");
        sb.AppendLine("{");
        foreach (var dtoClass in dtoClasses)
        {
            // Indent the DTO class
            var indentedClass = string.Join(
                "\n",
                dtoClass
                    .Split('\n')
                    .Select(line => string.IsNullOrWhiteSpace(line) ? line : "    " + line)
            );
            sb.AppendLine(indentedClass);
        }
        sb.AppendLine("}");

        return sb.ToString();
    }

    public override void GenerateCode(SourceProductionContext context)
    {
        try
        {
            var location =
                SemanticModel.GetInterceptableLocation(Invocation)
                ?? throw new InvalidOperationException("Failed to get interceptable location.");

            // Add current location to the list
            if (!Locations.Contains(location))
            {
                Locations.Add(location);
            }

            // Analyze anonymous type structure
            var dtoStructure = GenerateDtoStructure();

            // Skip if properties are empty
            if (dtoStructure.Properties.Count == 0)
                return;

            // Generate unique ID (from namespace, DTO name, and structure hash)
            var structureHash = dtoStructure.GetUniqueId();
            var uniqueId = $"{TargetNamespace.Replace(".", "_")}_{ExplicitDtoName}_{structureHash}";

            // Generate DTO classes (including nested DTOs)
            var dtoClasses = new List<string>();
            var mainDtoName = GenerateDtoClasses(dtoStructure, dtoClasses);

            // Generate SelectExpr method with interceptor attributes (for all locations)
            var selectExprMethod = GenerateSelectExprMethodWithLocations(
                mainDtoName,
                dtoStructure,
                Locations
            );

            // Build final source code
            var sourceCode = BuildSourceCode(mainDtoName, dtoClasses, selectExprMethod);

            // Register with Source Generator
            context.AddSource($"GeneratedExpression_{uniqueId}.g.cs", sourceCode);
        }
        catch (Exception ex)
        {
            // Output error information for debugging
            var errorMessage = $"""
                /*
                 * Source Generator Error: {ex.Message}
                 * Stack Trace: {ex.StackTrace}
                 */
                """;
            var hash = Guid.NewGuid().ToString("N")[..8];
            context.AddSource($"GeneratorError_{hash}.g.cs", errorMessage);
        }
    }

    private string GenerateSelectExprMethodWithLocations(
        string dtoName,
        DtoStructure structure,
        List<InterceptableLocation> locations
    )
    {
        var accessibility = GetAccessibilityString(SourceType);
        var sourceTypeFullName = structure.SourceTypeFullName;
        var dtoFullName = $"global::{TargetNamespace}.{dtoName}";
        var sb = new StringBuilder();

        var count = 0;
        foreach (var loc in locations)
        {
            count++;
            var className = $"{dtoName}_{count:D4}";
            var methodDecl =
                $"public static IQueryable<TResult> SelectExpr_{className}<TIn, TResult>(";
            sb.AppendLine($"    {accessibility} static partial class GeneratedExpression");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// generated select expression method {dtoName}");
            sb.AppendLine($"        /// at {loc.GetDisplayLocation()}");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        {loc.GetInterceptsLocationAttributeSyntax()}");
            sb.AppendLine($"        {methodDecl}");
            sb.AppendLine($"            this IQueryable<TIn> query,");
            sb.AppendLine($"            Func<TIn, object> selector) where TResult : {dtoFullName}");
            sb.AppendLine($"        {{");
            sb.AppendLine(
                $"            return (IQueryable<TResult>)(object)((IQueryable<{sourceTypeFullName}>)(object)query).Select(s => new {dtoFullName}"
            );
            sb.AppendLine($"            {{");

            // Generate property assignments
            var propertyAssignments = structure
                .Properties.Select(prop =>
                {
                    var assignment = GeneratePropertyAssignment(prop, 12);
                    return $"                {prop.Name} = {assignment}";
                })
                .ToList();
            sb.AppendLine(string.Join($",\n", propertyAssignments));

            sb.AppendLine($"            }});");
            sb.AppendLine($"        }}");
            sb.AppendLine($"    }}");
        }
        return sb.ToString();
    }
}
