using System.Text;
using Basic.Reference.Assemblies;
using Linqraft.Core;
using Linqraft.Playground.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Linqraft.Playground.Services;

/// <summary>
/// Service for Linqraft code generation using Roslyn
/// This uses the actual Linqraft.Core library for semantic analysis and code generation.
/// </summary>
public class CodeGenerationService
{
    private static readonly Lazy<MetadataReference[]> LazyReferences = new(() => 
        Net90.References.All.ToArray());

    /// <summary>
    /// Generates Linqraft output based on multiple source files
    /// </summary>
    public GeneratedOutput GenerateOutput(IEnumerable<ProjectFile> files, LinqraftConfiguration? config = null)
    {
        config ??= new LinqraftConfiguration { CommentOutput = CommentOutputMode.None };
        
        try
        {
            // Parse each file into its own syntax tree
            var syntaxTrees = files
                .Select(f => CSharpSyntaxTree.ParseText(f.Content, path: f.Path))
                .ToList();

            if (syntaxTrees.Count == 0)
            {
                return new GeneratedOutput
                {
                    QueryExpression = "// No source files provided",
                    DtoClass = "// No DTO class generated"
                };
            }

            // Create compilation with all syntax trees and reference assemblies
            var references = LazyReferences.Value;
            var compilation = CSharpCompilation.Create(
                "PlaygroundAnalysis",
                syntaxTrees,
                references,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
            );

            // Cache semantic models for each syntax tree
            var semanticModelCache = new Dictionary<SyntaxTree, SemanticModel>();
            SemanticModel GetSemanticModelCached(SyntaxTree tree)
            {
                if (!semanticModelCache.TryGetValue(tree, out var model))
                {
                    model = compilation.GetSemanticModel(tree);
                    semanticModelCache[tree] = model;
                }
                return model;
            }

            // Find SelectExpr invocations from all syntax trees
            var allSelectExprInfos = new List<SelectExprInfo>();
            foreach (var syntaxTree in syntaxTrees)
            {
                var semanticModel = GetSemanticModelCached(syntaxTree);
                var root = syntaxTree.GetRoot();
                var infos = FindSelectExprInvocations(root, semanticModel);
                allSelectExprInfos.AddRange(infos);
            }

            if (allSelectExprInfos.Count == 0)
            {
                return new GeneratedOutput
                {
                    QueryExpression = "// No SelectExpr call found in the code",
                    DtoClass = "// No DTO class generated"
                };
            }

            // Generate code for each SelectExpr
            var queryExpressionBuilder = new StringBuilder();
            var dtoClassBuilder = new StringBuilder();

            queryExpressionBuilder.AppendLine("// Generated by Linqraft Source Generator");
            queryExpressionBuilder.AppendLine("// This expression is automatically intercepted at compile-time");
            queryExpressionBuilder.AppendLine();

            dtoClassBuilder.AppendLine("// Generated by Linqraft Source Generator");
            dtoClassBuilder.AppendLine("// DTO classes are automatically created based on SelectExpr projections");
            dtoClassBuilder.AppendLine();

            foreach (var info in allSelectExprInfos)
            {
                try
                {
                    info.Configuration = config;

                    // Generate DTO classes
                    var dtoClasses = info.GenerateDtoClasses();
                    foreach (var dtoClass in dtoClasses)
                    {
                        var generatedCode = dtoClass.BuildCode(config);
                        dtoClassBuilder.AppendLine(generatedCode);
                        dtoClassBuilder.AppendLine();
                    }

                    // Generate the select expression (simplified representation)
                    var semanticModel = GetSemanticModelCached(info.Invocation.SyntaxTree);
                    var location = semanticModel.GetInterceptableLocation(info.Invocation);
                    if (location != null)
                    {
                        var selectExprCodes = info.GenerateSelectExprCodes(location);
                        foreach (var selectCode in selectExprCodes)
                        {
                            queryExpressionBuilder.AppendLine(selectCode);
                            queryExpressionBuilder.AppendLine();
                        }
                    }
                }
                catch (Exception ex)
                {
                    queryExpressionBuilder.AppendLine($"// Error processing SelectExpr: {ex.Message}");
                }
            }

            return new GeneratedOutput
            {
                QueryExpression = queryExpressionBuilder.ToString().TrimEnd(),
                DtoClass = dtoClassBuilder.ToString().TrimEnd()
            };
        }
        catch (Exception ex)
        {
            return new GeneratedOutput
            {
                ErrorMessage = $"Error generating output: {ex.Message}"
            };
        }
    }

    private static List<SelectExprInfo> FindSelectExprInvocations(SyntaxNode root, SemanticModel semanticModel)
    {
        var results = new List<SelectExprInfo>();

        var invocations = root.DescendantNodes().OfType<InvocationExpressionSyntax>();

        foreach (var invocation in invocations)
        {
            if (!IsSelectExprInvocation(invocation))
                continue;

            var info = GetSelectExprInfo(invocation, semanticModel);
            if (info != null)
            {
                results.Add(info);
            }
        }

        return results;
    }

    private static bool IsSelectExprInvocation(InvocationExpressionSyntax invocation)
    {
        var expression = invocation.Expression;
        return SelectExprHelper.IsSelectExprInvocationSyntax(expression);
    }

    private static SelectExprInfo? GetSelectExprInfo(InvocationExpressionSyntax invocation, SemanticModel semanticModel)
    {
        // Get lambda expression from arguments
        if (invocation.ArgumentList.Arguments.Count == 0)
            return null;

        var lambdaArg = invocation.ArgumentList.Arguments[0].Expression;
        if (lambdaArg is not LambdaExpressionSyntax lambda)
            return null;

        // Extract lambda parameter name
        var lambdaParamName = GetLambdaParameterName(lambda);

        // Extract capture argument info (if present)
        var (captureArgExpr, captureType) = GetCaptureInfo(invocation, semanticModel);

        var body = lambda.Body;

        // Check for different SelectExpr patterns
        if (body is ObjectCreationExpressionSyntax objCreation)
        {
            return GetNamedSelectExprInfo(invocation, objCreation, lambdaParamName, semanticModel, captureArgExpr, captureType);
        }

        if (invocation.Expression is MemberAccessExpressionSyntax memberAccess
            && memberAccess.Name is GenericNameSyntax genericName
            && genericName.TypeArgumentList.Arguments.Count >= 2
            && body is AnonymousObjectCreationExpressionSyntax anonSyntax)
        {
            return GetExplicitDtoSelectExprInfo(invocation, anonSyntax, genericName, lambdaParamName, semanticModel, captureArgExpr, captureType);
        }

        if (body is AnonymousObjectCreationExpressionSyntax anon)
        {
            return GetAnonymousSelectExprInfo(invocation, anon, lambdaParamName, semanticModel, captureArgExpr, captureType);
        }

        return null;
    }

    private static string GetLambdaParameterName(LambdaExpressionSyntax lambda)
    {
        return lambda switch
        {
            SimpleLambdaExpressionSyntax simple => simple.Parameter.Identifier.Text,
            ParenthesizedLambdaExpressionSyntax paren when paren.ParameterList.Parameters.Count > 0 
                => paren.ParameterList.Parameters[0].Identifier.Text,
            _ => "x"
        };
    }

    private static (ExpressionSyntax? captureArgExpr, ITypeSymbol? captureType) GetCaptureInfo(
        InvocationExpressionSyntax invocation,
        SemanticModel semanticModel)
    {
        ExpressionSyntax? captureArgExpr = null;
        ITypeSymbol? captureType = null;
        if (invocation.ArgumentList.Arguments.Count == 2)
        {
            captureArgExpr = invocation.ArgumentList.Arguments[1].Expression;
            var typeInfo = semanticModel.GetTypeInfo(captureArgExpr);
            captureType = typeInfo.Type ?? typeInfo.ConvertedType;
        }
        return (captureArgExpr, captureType);
    }

    private static SelectExprInfoAnonymous? GetAnonymousSelectExprInfo(
        InvocationExpressionSyntax invocation,
        AnonymousObjectCreationExpressionSyntax anonymousObj,
        string lambdaParameterName,
        SemanticModel semanticModel,
        ExpressionSyntax? captureArgumentExpression,
        ITypeSymbol? captureArgumentType)
    {
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        var namespaceDecl = invocation.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        var callerNamespace = namespaceDecl?.Name.ToString() ?? "";

        return new SelectExprInfoAnonymous
        {
            SourceType = sourceType,
            AnonymousObject = anonymousObj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            LambdaParameterName = lambdaParameterName,
            CallerNamespace = callerNamespace,
            CaptureArgumentExpression = captureArgumentExpression,
            CaptureArgumentType = captureArgumentType,
        };
    }

    private static SelectExprInfoNamed? GetNamedSelectExprInfo(
        InvocationExpressionSyntax invocation,
        ObjectCreationExpressionSyntax obj,
        string lambdaParameterName,
        SemanticModel semanticModel,
        ExpressionSyntax? captureArgumentExpression,
        ITypeSymbol? captureArgumentType)
    {
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        var namespaceDecl = invocation.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        var callerNamespace = namespaceDecl?.Name.ToString() ?? "";

        return new SelectExprInfoNamed
        {
            SourceType = sourceType,
            ObjectCreation = obj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            LambdaParameterName = lambdaParameterName,
            CallerNamespace = callerNamespace,
            CaptureArgumentExpression = captureArgumentExpression,
            CaptureArgumentType = captureArgumentType,
        };
    }

    private static SelectExprInfoExplicitDto? GetExplicitDtoSelectExprInfo(
        InvocationExpressionSyntax invocation,
        AnonymousObjectCreationExpressionSyntax anonymousObj,
        GenericNameSyntax genericName,
        string lambdaParameterName,
        SemanticModel semanticModel,
        ExpressionSyntax? captureArgumentExpression,
        ITypeSymbol? captureArgumentType)
    {
        if (invocation.Expression is not MemberAccessExpressionSyntax memberAccess)
            return null;

        var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);
        if (typeInfo.Type is not INamedTypeSymbol namedType)
            return null;

        var sourceType = namedType.TypeArguments.FirstOrDefault();
        if (sourceType is null)
            return null;

        var typeArguments = genericName.TypeArgumentList.Arguments;
        if (typeArguments.Count < 2)
            return null;

        var tResultType = semanticModel.GetTypeInfo(typeArguments[1]).Type;
        if (tResultType is null)
            return null;

        var explicitDtoName = tResultType.Name;

        var parentClasses = new List<string>();
        var currentContaining = tResultType.ContainingType;
        while (currentContaining is not null)
        {
            parentClasses.Insert(0, currentContaining.Name);
            currentContaining = currentContaining.ContainingType;
        }

        var namespaceDecl = invocation.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        var targetNamespace = namespaceDecl?.Name.ToString() ?? "";

        return new SelectExprInfoExplicitDto
        {
            SourceType = sourceType,
            AnonymousObject = anonymousObj,
            SemanticModel = semanticModel,
            Invocation = invocation,
            ExplicitDtoName = explicitDtoName,
            TargetNamespace = targetNamespace,
            LambdaParameterName = lambdaParameterName,
            CallerNamespace = targetNamespace,
            ParentClasses = parentClasses,
            TResultType = tResultType,
            CaptureArgumentExpression = captureArgumentExpression,
            CaptureArgumentType = captureArgumentType,
        };
    }
}
