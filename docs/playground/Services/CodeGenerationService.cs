using System.Text;
using System.Text.RegularExpressions;
using Linqraft.Playground.Models;

namespace Linqraft.Playground.Services;

/// <summary>
/// Service for simulating Linqraft code generation
/// This provides a simplified simulation of what the actual source generator does
/// </summary>
public partial class CodeGenerationService
{
    /// <summary>
    /// Generates simulated Linqraft output based on the input code
    /// </summary>
    public GeneratedOutput GenerateOutput(string code)
    {
        try
        {
            // Find SelectExpr calls in the code
            var selectExprMatch = SelectExprPattern().Match(code);
            if (!selectExprMatch.Success)
            {
                return new GeneratedOutput
                {
                    QueryExpression = "// No SelectExpr call found in the code",
                    DtoClass = "// No DTO class generated"
                };
            }

            var lambdaBody = selectExprMatch.Groups["body"].Value;
            var dtoTypeName = selectExprMatch.Groups["dtoType"].Value;
            var isExplicitDto = !string.IsNullOrEmpty(dtoTypeName);

            // Parse the anonymous object properties
            var properties = ParseAnonymousObjectProperties(lambdaBody);

            // Generate the expression
            var queryExpression = GenerateSelectExpression(properties, isExplicitDto, dtoTypeName);

            // Generate the DTO class
            var dtoClass = GenerateDtoClass(properties, isExplicitDto, dtoTypeName);

            return new GeneratedOutput
            {
                QueryExpression = queryExpression,
                DtoClass = dtoClass
            };
        }
        catch (Exception ex)
        {
            return new GeneratedOutput
            {
                ErrorMessage = $"Error generating output: {ex.Message}"
            };
        }
    }

    private static List<PropertyInfo> ParseAnonymousObjectProperties(string lambdaBody)
    {
        var properties = new List<PropertyInfo>();

        // Match property assignments like: PropertyName = expression, or just x.PropertyName,
        var propertyMatches = PropertyPattern().Matches(lambdaBody);

        foreach (Match match in propertyMatches)
        {
            var propName = match.Groups["name"].Value;
            var propValue = match.Groups["value"].Value;

            if (string.IsNullOrEmpty(propName) && !string.IsNullOrEmpty(propValue))
            {
                // Handle shorthand syntax like x.Id
                var simplePropertyMatch = SimplePropertyPattern().Match(propValue.Trim());
                if (simplePropertyMatch.Success)
                {
                    propName = simplePropertyMatch.Groups["propName"].Value;
                }
            }

            if (!string.IsNullOrEmpty(propName))
            {
                var propertyType = InferPropertyType(propValue);
                properties.Add(new PropertyInfo
                {
                    Name = propName,
                    Expression = propValue,
                    Type = propertyType,
                    IsNullable = propValue.Contains("?.")
                });
            }
        }

        return properties;
    }

    private static string InferPropertyType(string expression)
    {
        if (string.IsNullOrEmpty(expression))
            return "object";

        expression = expression.Trim();

        // Check for nested Select (collection)
        if (expression.Contains(".Select("))
        {
            if (expression.Contains(".ToList()"))
                return "List<object>";
            return "IEnumerable<object>";
        }

        // Check for common patterns
        if (expression.Contains("Id"))
            return "int";

        if (expression.Contains("Name") || expression.Contains("Description") ||
            expression.Contains("Email") || expression.Contains("Street") ||
            expression.Contains("City") || expression.Contains("Country") ||
            expression.Contains("Code"))
            return "string";

        if (expression.Contains("Date"))
            return "DateTime";

        if (expression.Contains("Price") || expression.Contains("Amount"))
            return "decimal";

        if (expression.Contains("Quantity") || expression.Contains("Count"))
            return "int";

        return "object";
    }

    private static string GenerateSelectExpression(List<PropertyInfo> properties, bool isExplicitDto, string dtoTypeName)
    {
        var sb = new StringBuilder();
        var resultType = isExplicitDto && !string.IsNullOrEmpty(dtoTypeName) ? dtoTypeName : "AnonymousType";

        sb.AppendLine("// Generated by Linqraft Source Generator");
        sb.AppendLine("// This expression is automatically intercepted at compile-time");
        sb.AppendLine();
        sb.AppendLine($"public static Expression<Func<TSource, {resultType}>> GetSelectExpression<TSource>()");
        sb.AppendLine("{");
        sb.AppendLine("    // Parameter: x => ...");
        sb.AppendLine("    var parameter = Expression.Parameter(typeof(TSource), \"x\");");
        sb.AppendLine();
        sb.AppendLine("    // Member bindings for each property");
        sb.AppendLine("    var bindings = new List<MemberBinding>");
        sb.AppendLine("    {");

        foreach (var prop in properties)
        {
            var nullableComment = prop.IsNullable ? " // With null-conditional handling" : "";
            sb.AppendLine($"        // {prop.Name} = {TruncateExpression(prop.Expression)}{nullableComment}");
            sb.AppendLine($"        Expression.Bind(");
            sb.AppendLine($"            typeof({resultType}).GetProperty(\"{prop.Name}\")!,");

            if (prop.IsNullable)
            {
                sb.AppendLine($"            CreateNullConditionalExpression(parameter, \"{prop.Expression.Replace("\"", "\\\"")}\")");
            }
            else if (prop.Expression.Contains(".Select("))
            {
                sb.AppendLine($"            CreateNestedSelectExpression(parameter, /* nested select */)");
            }
            else
            {
                sb.AppendLine($"            Expression.PropertyOrField(parameter, \"{prop.Name}\")");
            }
            sb.AppendLine("        ),");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine($"    var body = Expression.MemberInit(");
        sb.AppendLine($"        Expression.New(typeof({resultType})),");
        sb.AppendLine($"        bindings");
        sb.AppendLine($"    );");
        sb.AppendLine();
        sb.AppendLine($"    return Expression.Lambda<Func<TSource, {resultType}>>(body, parameter);");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateDtoClass(List<PropertyInfo> properties, bool isExplicitDto, string dtoTypeName)
    {
        var sb = new StringBuilder();
        var className = isExplicitDto && !string.IsNullOrEmpty(dtoTypeName) ? dtoTypeName : "GeneratedDto";

        sb.AppendLine("// Generated by Linqraft Source Generator");
        sb.AppendLine("// This DTO class is automatically created based on the SelectExpr projection");
        sb.AppendLine();
        sb.AppendLine($"public partial class {className}");
        sb.AppendLine("{");

        foreach (var prop in properties)
        {
            var nullableMarker = prop.IsNullable && prop.Type != "int" ? "?" : "";
            sb.AppendLine($"    public {prop.Type}{nullableMarker} {prop.Name} {{ get; set; }}");
        }

        sb.AppendLine("}");

        // If there are nested selects, generate nested DTOs
        var nestedProps = properties.Where(p => p.Expression.Contains(".Select(")).ToList();
        if (nestedProps.Count != 0)
        {
            sb.AppendLine();
            sb.AppendLine("// Nested DTO for collection projections");
            foreach (var nestedProp in nestedProps)
            {
                sb.AppendLine($"public partial class {nestedProp.Name}Item");
                sb.AppendLine("{");
                sb.AppendLine("    // Properties extracted from nested Select");
                sb.AppendLine("    public string? Name { get; set; }");
                sb.AppendLine("    public int Quantity { get; set; }");
                sb.AppendLine("}");
            }
        }

        return sb.ToString();
    }

    private static string TruncateExpression(string expression)
    {
        if (expression.Length > 50)
            return expression[..47] + "...";
        return expression;
    }

    // Regex patterns
    [GeneratedRegex(@"\.SelectExpr(?:<(?<dtoType>\w+)>)?\s*\(\s*\w+\s*=>\s*new\s*(?:\w+\s*)?\{(?<body>[\s\S]*?)\}\s*\)", RegexOptions.Compiled)]
    private static partial Regex SelectExprPattern();

    [GeneratedRegex(@"(?:(?<name>\w+)\s*=\s*)?(?<value>[^,\}]+)", RegexOptions.Compiled)]
    private static partial Regex PropertyPattern();

    [GeneratedRegex(@"^\w+\.(?<propName>\w+)$", RegexOptions.Compiled)]
    private static partial Regex SimplePropertyPattern();

    private class PropertyInfo
    {
        public string Name { get; set; } = "";
        public string Expression { get; set; } = "";
        public string Type { get; set; } = "object";
        public bool IsNullable { get; set; }
    }
}
