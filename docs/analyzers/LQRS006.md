# LQRS006 - NestedSelectExprPartialDtoAnalyzer

**Severity:** Error  
**Category:** Usage  
**Default:** Enabled

## Description
Reports missing `partial` class declarations when using nested `SelectExpr` with explicit DTO types. When `SelectExpr` is used inside another `SelectExpr`, the source generator requires empty `partial` class declarations for all DTO types to correctly identify and generate the types.

Without these declarations, DTOs may be generated in the wrong location or fail to generate entirely, as the Roslyn API cannot correctly identify the generated types during compilation.

## Why Partial Declarations Are Required

When evaluating nested expressions using the Roslyn API, if the target DTO class is not pre-declared as `partial`, the source generator cannot correctly identify the type being referenced. For example:

- If `OrderItemDto` is not pre-defined as `partial`, the property type that should be `IEnumerable<OrderItemDto>` will be treated as an unknown type (`?`), causing DTO generation to fail.
- If `OrderDto` is not defined as `partial`, the generation location of `OrderItemDto` becomes unclear, leading to it being generated in the wrong namespace.

Therefore, it is essential to declare empty `partial` class definitions for **all** DTO types used in nested `SelectExpr` calls.

## When It Triggers

This analyzer triggers when:
1. A `SelectExpr<TSource, TDto>` call contains nested `SelectExpr<TSource2, TDto2>` calls
2. One or more of the DTO types (`TDto`, `TDto2`, etc.) lack corresponding `partial` class declarations in the same file

**Note:** This analyzer does **not** trigger for:
- Single-level `SelectExpr` calls (without nested `SelectExpr`)
- DTO types that are already generated by the source generator (marked with `LinqraftAutoGeneratedDtoAttribute`)

## Code Fix Behavior

`NestedSelectExprPartialDtoCodeFixProvider` will:
- Identify all DTO types required by the nested `SelectExpr` calls
- Generate empty `internal partial class` declarations for any missing types
- Add the declarations at the end of the file (or at the end of the namespace if one exists)
- Properly format the code with appropriate line endings

## Example

**Before (triggers LQRS006):**
```csharp
var result = query
    .SelectExpr<Order, OrderDto>(o => new
    {
        o.Id,
        o.CustomerName,
        Items = o.OrderItems.SelectExpr<OrderItem, OrderItemDto>(i => new
        {
            i.ProductName,
            i.Quantity,
        }),
    });

// Missing: partial class declarations for OrderDto and OrderItemDto
```

**After (code fix adds partial declarations):**
```csharp
var result = query
    .SelectExpr<Order, OrderDto>(o => new
    {
        o.Id,
        o.CustomerName,
        Items = o.OrderItems.SelectExpr<OrderItem, OrderItemDto>(i => new
        {
            i.ProductName,
            i.Quantity,
        }),
    });

// Partial class declarations added by code fix
internal partial class OrderDto;
internal partial class OrderItemDto;
```

## Multiple Nesting Levels

The analyzer handles multiple levels of nesting and ensures all DTO types are declared:

```csharp
var result = query
    .SelectExpr<Entity, EntityDto>(x => new
    {
        x.Id,
        Items = x.Items.SelectExpr<Item, ItemDto>(i => new
        {
            i.Id,
            SubItems = i.SubItems.SelectExpr<SubItem, SubItemDto>(si => new
            {
                si.Value,
            }),
        }),
    });

// All three partial class declarations required:
internal partial class EntityDto;
internal partial class ItemDto;
internal partial class SubItemDto;
```

## See Also
- [Nested SelectExpr Documentation](../library/nested-selectexpr.md) - Detailed guide on using nested `SelectExpr`
- [Partial Classes Documentation](../library/partial-classes.md) - How to extend generated DTOs
